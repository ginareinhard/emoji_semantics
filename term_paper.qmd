---
title: "Term paper"
subtitle: ""
author: "Rose Hörsting & Gina Reinhard"
date: "2024-09-15"
engine: knitr
bibliography: references.bib
format: 
  html:
    toc: true
    toc-depth: 3
    number-sections: true
    embed-resources: true
    fig-width: 10
    fig-height: 8
link-citations: true
csl: "apa_7th.csl"
---

```{r ragg, include=FALSE}

#install.packages("ragg")
library(ragg)

```

```{r setup, include=FALSE}

knitr::opts_chunk$set(dev = "ragg_png")

```

```{r include=FALSE}

library(checkdown)

```

#### **Chapter overview** {.unnumbered}

In this chapter, we...

## Session set up

```{r load-libraries, message=FALSE}

library(here)
library(tidyverse)
#install.packages("ggpubr")
library(ggpubr)
#install.packages("scales")
library(scales)
#install.packages(patchwork)
library(patchwork)

```

## Introducing the study

@fricke2024semantic \> Fricke, L., Grosz, P. G., & Scheffler, T. (2024). Semantic differences in visually similar face emojis. Language and Cognition, 1–15. \<httpsdoi:10.1017/langcog.2024.12\>.

::: {.callout-note title="How did the experiment work?"}
...

They used the face emoji annotation system developed by @fugate2021implications, Facial Action Coding System (FACS) by @ekman1978facial. FACS decomposes facial expressions into minimal Action Units (AUs) which makes the annotation of face emojis possible.

Pictorial approach @maier2023emojis vs. lexicalist approach @grosz2023semantics.

Goal: Test the predictions of the pictorial approach, i.e.: There should be a clear preference for the context-matching emoji for emoji pairs with an \[AU+\] difference. For emojis without an AU difference \[AU-\], context-matching emojis should be chosen less often (p.7)

Question: Do AU differences lead to differences in meaning between the two emojis of a pair? Hypothesis: "Small visual differences that do not correspond to AU differences ((no clear real-life counterparts)) should be semantically less relevant than visual differences that do correspond to AU differences" (4) Method: three \[AU+\] and three \[AU\] emoji pairs, rendered in WhatsApp Android version; each emoji to occur on one pair; no emojis with symbolic components (5) Task: participants must choose between emojis of a pair (Forced choce task), help "Alex/Anna" help using the emoji that best matches the text (6)
:::

![Image from @fricke2024semantic](images/emoji_pairs.png){#fig-emojipairs fig-align="center"}

![Image from @fricke2024semantic](images/emoji_use.png){#fig-emojiuse fig-align="center" width="500"}

![Image from @fricke2024semantic](images/emoji_attitude.png){#fig-emojiattitude fig-align="center" width="500"}

## Inserting emojis in R

(move this chapter/subchapter?)

Insert emojis via emoji keyboard (Shortcut fn+e on Mac), also available in R Studio (Edit -\> Emojis & Symbols). This is the easiest way. Alternatively, there are emoji libraries, e.g. "emo(ji)" (<https://github.com/hadley/emo>).

As we want to display emojis within plots using ggplot: We have to use AGG/Cairo? as Backend in R Studio (Tools -\> Global Options -\> Graphics -\> Backend -\> AGG) \[explain AGG/Cairo\]. Only necessary for Mac?

For rendering the output from qmd (or Markdown?) to HTML (or pdf?) we can:

-   save the plots with ggsave() and insert them
-   use the ragg library (<https://ragg.r-lib.org>) ("ragg can be used as the graphic back-end to the RStudio device (for RStudio \>= 1.4) by choosing *AGG* as the backend in the graphics pane in general options (see screenshot)")

## Data wrangling

Import the data using "here":

```{r import-data, message=FALSE}

raw_data <- read.csv(file = here("data", "raw_data.csv"))

```

Filter out participants who exceed the maximum age of 35 years specified by @fricke2024semantic (p. 8):

```{r clean-data}

data <- raw_data |> 
  filter(age <= 35)

```

Create a column with the experimental conditions (AU+, AU-, and filler/control items) using a combination of str_detect, case_when and mutate:

```{r}

#delete this code chunk?

data <- data |>
  mutate(AU_difference = case_when(str_detect(name, "AU") ~ "yes",
                                   str_detect(name, "N") ~ "no",
                                   str_detect(name, "filler") ~ "filler",
                                   .default = NULL))

table(data$AU_difference)

```

Filter out filler emojis:

```{r}

data_without_fillers <- data |>
  filter(AU_difference != "filler")

# alternative (if code chunk above is deleted): 
#data_without_fillers <- data |> 
#  filter(!str_detect(name, "filler"))

```

Define contexts using a combination of str_detect, case_when and mutate (and check output with table()):

```{r}

data_without_fillers <- data_without_fillers |> 
  mutate(context = case_when(str_detect(question, "freut sich") ~ "happiness", #Fricke et al.: general happiness
                             str_detect(question, "lacht") ~ "(cheeky) laughter", #hearty laughter 

                             str_detect(question, "macht sich Sorgen") ~ "concern",
                             str_detect(question, "ist überrascht") ~ "surprise",
                             str_detect(question, "ist etwas genervt") ~ "mild irritation",
                             str_detect(question, "ärgert sich") ~ "annoyance",
                             str_detect(question, "amüsiert sich") ~ "amusement",
                             str_detect(question, "ist überglücklich") ~ "(intense) happiness", #overhappy
                             str_detect(question, "ist enttäuscht") ~ "mild disappointment",
                             #str_detect(question, "ist enttäuscht") ~ "moderate disappointment",
                             str_detect(question, "ist gut gelaunt") ~ "happiness2", #called this "happiness2" for now, Fricke et al.: happiness
                             str_detect(question, "ist verlegen") ~ "bashfulness",
                                   .default = NULL))

table(data_without_fillers$context)

```

Problem: emoji pair "slightly frowning face" and "frowning face" with the same question/context "ist enttäuscht". This is only resolvable using/citing the information from the original analysis script? (meaning of N-36 = "mild disappointment", meaning of N-37 = "moderate disappointment")

```{r}

data_without_fillers <- data_without_fillers |> 
  mutate(context = case_when(
                             str_detect(name, "N-36") ~ "mild disappointment",
                             str_detect(name, "N-37") ~ "moderate disappointment",
                                   .default = context))

table(data_without_fillers$context)

```

Define matches:

```{r}

data_without_fillers <- data_without_fillers |> 
  mutate(
  match = case_when( #called it match for now, potentially the only match column needed?
    context == "happiness" & response == "grinning_face_with_big_eyes" ~ "yes",
    context == "(cheeky) laughter" & response == "grinning_squinting_face" ~ "yes",
    context == "concern" & response == "hushed_face" ~ "yes",
    context == "surprise" & response == "astonished_face" ~ "yes",
    context == "mild irritation" & response == "neutral_face" ~ "yes",
    context == "annoyance" & response == "expressionless_face" ~ "yes",
    context == "amusement" & response == "grinning_face_with_smiling_eyes" ~ "yes",
    context == "(intense) happiness" & response == "beaming_face_with_smiling_eyes" ~ "yes",
    context == "mild disappointment" & response == "slightly_frowning_face" ~ "yes",
    context == "moderate disappointment" & response == "frowning_face" ~ "yes",
    context == "happiness2" & response == "smiling_face_with_smiling_eyes" ~ "yes",
    context == "bashfulness" & response == "smiling_face" ~ "yes",
    .default = "no"))

```

## Data analysis/visualisation

### Descriptive statistics

### Walkthrough bar plot

### Explore the relationship between gender and emoji understanding

To get an overview of how the values of the gender variable are distributed, we look at the data using the ´table()´ function.

```{r, results=TRUE}

table(raw_data$gender)

```

The gender distribution in the data is very uneven: 109 men, 47 women and 3 non-binary people participated in the study. In order not to skew the visualisations, @fricke2024semantic excluded the three participants with non-binary gender.

```{r}

table(raw_data$emoji_understanding)

```

```{r gender-count, results=FALSE}

gender_count <- data |> 
  group_by(submission_id) |> 
  count(gender)

table(gender_count$gender)

```

```{r}

data <- data |> 
  filter(gender != "divers")

```

Add a column with self-reported emoji understanding by gender (men/women), relative frequencies:

```{r}

gender_understanding_count <- data |> 
  distinct(submission_id, .keep_all = TRUE) |> #keep only the first occurrence of each unique submission_id
  mutate(gender = recode(gender, "männlich" = "men", "weiblich" = "women")) |>
    mutate(emoji_understanding = recode(emoji_understanding, "mittelmäßig" = "moderate", "eher gut" = "rather good", "gut" = "good", "sehr gut" = "very good")) |>
    mutate(emoji_understanding = factor(emoji_understanding, levels = c("moderate", "rather good", "good", "very good"))) |>
  group_by(gender) |> 
  count(gender, emoji_understanding) |> 
  mutate(total = sum(n), 
         percentage = (n/total) * 100)

```

Plot self-reported emoji understanding by gender (male and female), relative frequencies, adjust color manually to colors of @fricke2024semantic:

```{r}

ggplot(gender_understanding_count, aes(x = emoji_understanding, y = percentage, fill = gender)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Self-reported Emoji Understanding by Gender",
       x = "Emoji understanding",
       y = "Percent") +
  scale_fill_manual(values=c("#003560", "#B61E3E"))

```

```{r match count}

match_count <- data_without_fillers |> 
  group_by(match) |> 
  count()

#   match     n
#   <chr>  <int>
# 1 no       583
# 2 yes     1325

```

```{r plot match x emoji use}

#trying to see whether there is a correlation of emoji use and matching accuracy
match_use_count <- data_without_fillers |> 
  group_by(match, emoji_use) |> 
  count()

match_use_count |> 
  group_by(emoji_use) |> 
  ggplot(aes(x = emoji_use, y = n, fill = match)) +
  geom_bar(stat = "identity", position = "dodge") + #better with position = "dodge" or default position = "stack"?
  labs(x = "Use frequency", y = "count")
#there seem to be considerable differences between values

match_use_count |> 
  ggplot(aes(x = emoji_use, y = n, fill = match)) + 
  geom_bar(stat = "identity", show.legend = TRUE, position = "fill") +
  scale_fill_brewer(palette="Set1")+
  labs(title = "Do participants that use emojis less frequently have a lower matching accuracy?",
       x = "Use frequency",
       y = "Ratio")+
  coord_flip()

#the plot does not really look meaningful, i.e. there is not a real difference when scaled up to 100%

```

## AU plot

```{r AU difference , matching rates, context}

perc_AU_diff <- data_without_fillers |> 
  group_by(context) |> 
  count(match) |> #counts matches and non-matches (match((yes/no)) for each context
  mutate(percent = round(n/sum(n)*100, 2)) #creates a new column with the percentages for each of the above counts (in relation to the sum of all matches/non-matches within each context, rounded to 2 digits)

```

Creating a stacked bar plot for the first (AU+) condition, emoji pair 😯 😲, contexts concern and surprise.

```{r}

plot_concern_surprise <- perc_AU_diff |> 
filter(context == "concern" | context == "surprise") |> 
ggplot(aes(x = context, y = percent, fill = match)) +
geom_bar(stat = "identity") +
scale_x_discrete(limits = c("concern", "surprise")) +
geom_text(aes(label = percent), position = position_stack(vjust = 0.5)) +
labs (x= "", y = "", title = "😯 😲") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))

plot_concern_surprise

```

Since we have to do this with all emoji pairs, we define a function.

```{r}

plot_AU_matches <- function(contexts, emojis) {
  perc_AU_diff |> 
    filter(context %in% contexts) |> 
    ggplot(aes(x = context, y = percent, fill = match)) +
    geom_col() +
    scale_x_discrete(limits = contexts) +
    geom_text(aes(label = percent), position = position_stack(vjust = 0.5)) +
    labs (x= "context", y = "percent", title = emojis) +
    theme_bw() +
    theme(plot.title = element_text(hjust = 0.5))
}

```

We apply this function to all emoji pairs and contexts.

```{r}

plot_concern_surprise <- plot_AU_matches(c("concern", "surprise"), "😯 😲")
plot_happiness_cheeky <- plot_AU_matches(c("happiness", "(cheeky) laughter"), "😃 😆")
plot_mild_irr_annoyance <- plot_AU_matches(c("mild irritation", "annoyance"), "😐 😑")
plot_mild_disapp_mod_dissap <- plot_AU_matches(c("mild disappointment", "moderate disappointment"), "🙁️ ☹️")
plot_amusement_int_happiness <- plot_AU_matches(c("amusement", "(intense) happiness"), "😄 😁")
plot_happiness2_bashfulness <- plot_AU_matches(c("happiness2", "bashfulness"), "😊 ☺️")

```

### ggarrange

Arranging all AU+ conditions together in one plot, arranging all AU- conditions together in one plot.

```{r}

AU_plus <- ggarrange(plot_concern_surprise, plot_happiness_cheeky, plot_mild_irr_annoyance,
#labels = "AU+ condition",
common.legend = TRUE, legend = "right",
nrow = 3, ncol = 1)

AU_plus <- annotate_figure(AU_plus,
top = text_grob("[AU+] condition"))

AU_minus <- ggarrange(plot_mild_disapp_mod_dissap, plot_amusement_int_happiness, plot_happiness2_bashfulness,
#labels = "AU- condition",
common.legend = TRUE, legend = "right",
nrow = 3, ncol = 1)

AU_minus <- annotate_figure(AU_minus,
top = text_grob("[AU-] condition"))

```

Combining the AU+ and AU- plots.

```{r}

AU_combined <- ggarrange(AU_plus, AU_minus,
ncol = 2)

# AU_combined <- annotate_figure(AU_combined, #also a function of the "ggpubr" package
# #top = text_grob("AU differences for individual contexts"),
# #left = text_grob("percent", rot = 90),
# bottom = text_grob("context"))

AU_combined

```

```{r}

ggsave(filename = "images/AU_plot.png", width = 3400, height = 2000, units = "px")

```

### Patchwork

![Patchwork artwork by Allison Horst](images/patchwork.png)

By applying our function `plot_AU_matches` to all emoji pairs and contexts, we have created one barplot for each emoji pair/ context. We will use the `patchwork` package (@pedersen2024patchwork) to assemble the plots in an overview-graph. As the name suggests, the `patchwork` package enables us to patch several plots together and arrange them nicely, so that the finished graph will be cohesive and informative.

#### Version 1

In line with the research question of @fricke2024semantic, we want to compare the emojis/contexts of the \[AU+\] condition with the emojis/contexts of the \[AU-\] condition. Therefore, we first put the according plots together in blocks of three. In the `patchwork` package, plots are combined by `|` (horizontally), `/` (vertically), and `+` (unspecific/ general). We will arrange the \[AU+\] plots on top of each other, as well as the \[AU-\] plots. The `plot_layout` function takes the argument `guides`. By setting this argument to `"collect"`, we specify that the legends of all plots should be merged. We name the plot assemblies `AU_plus_patch` and `AU_minus_patch` respectively.

```{r}
#AU+ conditions
AU_plus_patch <- 
  plot_concern_surprise / plot_happiness_cheeky / plot_mild_irr_annoyance +
  plot_layout(guides = "collect")

#AU- condition:
AU_minus_patch <- 
  plot_mild_disapp_mod_dissap / plot_amusement_int_happiness / plot_happiness2_bashfulness +
  plot_layout(guides = "collect")
```

Since `AU_plus_patch` and `AU_minus_patch` are to be combined in one graph, we need to add titles to them to keep them apart. Technically, it is possible (and recommended!) to do this by using the `plot_annotation` function of the `patchwork` package. However, annotations of this function are only shown at the highest nesting level. As we will be building a double-nested plot, any annotations we do on the "blocks-of-three"-level will not be displayed. We can work around this by using the function `wrap_elements`. This fixes the blocks in their current state and allows us to add titles that relate the blocks to the conditions. Unfortunately, there is one small downside to this approach, as we will see in a second.

```{r}
#need to use wrap_elements to add a title nested plots (otherwise the title is lost in the final nested plot)
AU_plus_patch <- wrap_elements(plot = AU_plus_patch) +
  ggtitle("[AU+] condition")

AU_minus_patch <- wrap_elements(plot = AU_minus_patch) +
  ggtitle("[AU-] condition")
```

Finally, we put both elements together to get our final graph.

```{r}
AU_combined_patch1 <- AU_plus_patch | AU_minus_patch
AU_combined_patch1
#problem: cannot collect the two legends of the nested plots, and if I strip away the legend of AU_plus_patch, the plots do not have the same widths because of the legend.
```

This graph contains information about the matching rates of all emoji pairs for their contexts. However, you will probably notice that we have two identical legends. That is not ideal, but it is the trade-off we take by using the `wrap_element` function: We have fixated the patchworks in their state with their legends, therefore the legends cannot be merged later. The options are to (1) delete the legends from both blocks, (2) keep the legend of one block and delete the other (this makes the bars take up the space of the legend, i.e. the bars in one block become wider than in the other one), (3) keep the legends of all six plots, or (4) collect the legends to get one legend for each condition. We have opted for (4), but feel free to try the other options for yourself and see how it affects the final product.

As you can see, building plots and assembling them can be quite fiddly and it is easy to get lost in details. It can take some time and a lot of trial-and-error to make the final plot look like what you have imagined. Maybe you will need to accept some trade-offs. However, there is a solution for (almost) anything and hopefully, the beautiful graph you create in the process can make up for the trouble.

::: callout-tip
#### Quiz time! {.unnumbered}

1)  Looking the final patchwork, which "sub-plot" shows the most significant finding?

```{r echo=FALSE, results="asis"}

check_question("lower left", options = c("upper left", "upper right", "middle left", "middle right", "lower left", "lower right"), type = "radio", 
random_answer_order = TRUE,
button_label = "Check answer", q_id = 5,
right = "Test right!",
wrong = "Test incorrect.")
```

2)  What does that mean/ how can we interpret that finding, also regarding the results of the other plots?
:::

#### Version 2

Alternative: create a plot without nesting before, so with all six plots. Problem: no other possibility to create "AU titles" other than adding the labels as separate objects.

```{r}
col_label1 <- wrap_elements(panel = text_grob("AU+ condition"))
col_label2 <- wrap_elements(panel = text_grob("AU- condition"))

AU_combined_patch2 <- 
  ((col_label1 / plot_concern_surprise / plot_happiness_cheeky / plot_mild_irr_annoyance) | (col_label2 / plot_mild_disapp_mod_dissap / plot_amusement_int_happiness / plot_happiness2_bashfulness)) +
  plot_layout(heights = c(.1,2,2,2,.2,2,2,2), guides = "collect") &
  theme(legend.position = "bottom")
 
AU_combined_patch2
#problem: a lot of white space around the condition labels

```

::: callout-tip
#### Quiz time! {.unnumbered}

1\) Test question?

```{r echo=FALSE, results="asis"}

check_question("D", options = c("A", "B", "C", "D", "E"), type = "radio", 
random_answer_order = TRUE,
button_label = "Check answer", q_id = 4,
right = "Test right!",
wrong = "Test incorrect.")

```
:::

## Conclusion

## References
