---
title: "Term paper"
subtitle: ""
author: "Rose Hörsting & Gina Reinhard"
date: "2024-09-15"
engine: knitr
bibliography: references.bib
format: 
  html:
    toc: true
    toc-depth: 3
    number-sections: true
    embed-resources: true
link-citations: true
csl: "apa_7th.csl"
---

```{r ragg, include=FALSE}

#install.packages("ragg")
library(ragg)

```

```{r setup, include=FALSE}

knitr::opts_chunk$set(dev = "ragg_png")

```

```{r include=FALSE}

library(checkdown)

```

#### **Chapter overview** {.unnumbered}

In this chapter, we...

```{r load-libraries, message=FALSE}

library(here)
library(tidyverse)
#install.packages("ggpubr")
library(ggpubr)
#install.packages("scales")
library(scales)

```

## Introducing the study

@fricke2024semantic \> Fricke, L., Grosz, P. G., & Scheffler, T. (2024). Semantic differences in visually similar face emojis. Language and Cognition, 1–15. \<httpsdoi:10.1017/langcog.2024.12\>.

::: {.callout-note title="How did the experiment work?"}
...

They used the face emoji annotation system developed by @fugate2021implications, Facial Action Coding System (FACS) by @ekman1978facial. FACS decomposes facial expressions into minimal Action Units (AUs) which makes the annotation of face emojis possible.

Pictorial approach @maier2023emojis vs. lexicalist approach @grosz2023semantics.

Goal: Test the predictions of the pictorial approach, i.e.: There should be a clear preference for the context-matching emoji for emoji pairs with an \[AU+\] difference. For emojis without an AU difference \[AU-\], context-matching emojis should be chosen less often (p.7)

Question: Do AU differences lead to differences in meaning between the two emojis of a pair? Hypothesis: "Small visual differences that do not correspond to AU differences ((no clear real-life counterparts)) should be semantically less relevant than visual differences that do correspond to AU differences" (4) Method: three \[AU+\] and three \[AU\] emoji pairs, rendered in WhatsApp Android version; each emoji to occur on one pair; no emojis with symbolic components (5) Task: participants must choose between emojis of a pair (Forced choce task), help "Alex/Anna" help using the emoji that best matches the text (6)
:::

![Image from @fricke2024semantic](images/emoji_pairs.png){#fig-emojipairs fig-align="center"}

![Image from @fricke2024semantic](images/emoji_use.png){#fig-emojiuse fig-align="center" width="500"}

![Image from @fricke2024semantic](images/emoji_attitude.png){#fig-emojiattitude fig-align="center" width="500"}

## Inserting emojis in R

(move this chapter/subchapter?)

Insert emojis via emoji keyboard (Shortcut fn+e on Mac), also available in R Studio (Edit -\> Emojis & Symbols). This is the easiest way. Alternatively, there are emoji libraries, e.g. "emo(ji)" (<https://github.com/hadley/emo>).

As we want to display emojis within plots using ggplot: We have to use AGG/Cairo? as Backend in R Studio (Tools -\> Global Options -\> Graphics -\> Backend -\> AGG) \[explain AGG/Cairo\]. Only necessary for Mac?

For rendering the output from qmd (or Markdown?) to HTML (or pdf?) we can:

-   save the plots with ggsave() and insert them
-   use the ragg library (<https://ragg.r-lib.org>) ("ragg can be used as the graphic back-end to the RStudio device (for RStudio \>= 1.4) by choosing *AGG* as the backend in the graphics pane in general options (see screenshot)")

## Data wrangling

Import the data using "here":

```{r import-data, message=FALSE}

raw_data <- read.csv(file = here("data", "raw_data.csv"))

```

Filter out participants who exceed the maximum age of 35 years specified by @fricke2024semantic (p. 8):

```{r clean-data}

data <- raw_data |> 
  filter(age <= 35)

```

```{r, results=FALSE}

table(raw_data$gender)
table(raw_data$emoji_understanding)

```

```{r gender-count, results=FALSE}

gender_count <- data |> 
  group_by(submission_id) |> 
  count(gender)

table(gender_count$gender)

```

-\> 109 specified male, 47 female, 3 non-binary. @fricke2024semantic excluded participants with non-binary gender, as there were only 3.

##### Question for Elen 1/6

Originally, we planned to include divers gender (unlike Fricke et al.) but because only three participants had divers gender, it skewed our visualisation: when using relative frequencies, the bars for divers genders become huge. On the other hand using absolute frequencies, the plot is not meaningful because significantly more males than females participated. Do you know a way to solve this without excluding divers genders?

```{r}

data <- data |> 
  filter(gender != "divers")

```

Add a column with self-reported emoji understanding by gender (men/women), relative frequencies:

```{r}

gender_understanding_count <- data |> 
  distinct(submission_id, .keep_all = TRUE) |> #keep only the first occurrence of each unique submission_id
  mutate(gender = recode(gender, "männlich" = "men", "weiblich" = "women")) |>
    mutate(emoji_understanding = recode(emoji_understanding, "mittelmäßig" = "moderate", "eher gut" = "rather good", "gut" = "good", "sehr gut" = "very good")) |>
    mutate(emoji_understanding = factor(emoji_understanding, levels = c("moderate", "rather good", "good", "very good"))) |>
  group_by(gender) |> 
  count(gender, emoji_understanding) |> 
  mutate(total = sum(n), 
         percentage = (n/total) * 100)

```

Create a column with the experimental conditions (AU+, AU-, and filler/control items) using a combination of str_detect, case_when and mutate:

```{r}

#delete this code chunk?

data <- data |>
  mutate(AU_difference = case_when(str_detect(name, "AU") ~ "yes",
                                   str_detect(name, "N") ~ "no",
                                   str_detect(name, "filler") ~ "filler",
                                   .default = NULL))

table(data$AU_difference)

```

Filter out filler emojis:

```{r}

data_without_fillers <- data |>
  filter(AU_difference != "filler")

# alternative (if code chunk above is deleted): 
#data_without_fillers <- data |> 
#  filter(!str_detect(name, "filler"))

```

Define contexts using a combination of str_detect, case_when and mutate (and check output with table()):

```{r}

data_without_fillers <- data_without_fillers |> 
  mutate(context = case_when(str_detect(question, "freut sich") ~ "happiness", #Fricke et al.: general happiness
                             str_detect(question, "lacht") ~ "(cheeky) laughter", #hearty laughter 

                             str_detect(question, "macht sich Sorgen") ~ "concern",
                             str_detect(question, "ist überrascht") ~ "surprise",
                             str_detect(question, "ist etwas genervt") ~ "mild irritation",
                             str_detect(question, "ärgert sich") ~ "annoyance",
                             str_detect(question, "amüsiert sich") ~ "amusement",
                             str_detect(question, "ist überglücklich") ~ "(intense) happiness", #overhappy
                             str_detect(question, "ist enttäuscht") ~ "mild disappointment",
                             #str_detect(question, "ist enttäuscht") ~ "moderate disappointment",
                             str_detect(question, "ist gut gelaunt") ~ "happiness2", #called this "happiness2" for now, Fricke et al.: happiness
                             str_detect(question, "ist verlegen") ~ "bashfulness",
                                   .default = NULL))

table(data_without_fillers$context)

```

Problem: emoji pair "slightly frowning face" and "frowning face" with the same question/context "ist enttäuscht". This is only resolvable using/citing the information from the original analysis script? (meaning of N-36 = "mild disappointment", meaning of N-37 = "moderate disappointment")

```{r}

data_without_fillers <- data_without_fillers |> 
  mutate(context = case_when(
                             str_detect(name, "N-36") ~ "mild disappointment",
                             str_detect(name, "N-37") ~ "moderate disappointment",
                                   .default = context))

table(data_without_fillers$context)

```

##### Question for Elen 2/6

Is it in this case acceptable to cite the analysis script of Fricke et al.? We do not see another possibility since the contexts for "mild disappointment" and "moderate disappointment" are exactly identical except für the coded names of the emojis. The coding of the emojis (data\$name) is not transparent to us: It corresponds somewhat, but not completely, to the AU coding.

Define matches:

```{r}

data_without_fillers <- data_without_fillers |> 
  mutate(
  match = case_when( #called it match for now, potentially the only match column needed?
    context == "happiness" & response == "grinning_face_with_big_eyes" ~ "yes",
    context == "(cheeky) laughter" & response == "grinning_squinting_face" ~ "yes",
    context == "concern" & response == "hushed_face" ~ "yes",
    context == "surprise" & response == "astonished_face" ~ "yes",
    context == "mild irritation" & response == "neutral_face" ~ "yes",
    context == "annoyance" & response == "expressionless_face" ~ "yes",
    context == "amusement" & response == "grinning_face_with_smiling_eyes" ~ "yes",
    context == "(intense) happiness" & response == "beaming_face_with_smiling_eyes" ~ "yes",
    context == "mild disappointment" & response == "slightly_frowning_face" ~ "yes",
    context == "moderate disappointment" & response == "frowning_face" ~ "yes",
    context == "happiness2" & response == "smiling_face_with_smiling_eyes" ~ "yes",
    context == "bashfulness" & response == "smiling_face" ~ "yes",
    .default = "no"))

```

## Data analysis/visualisation

### Descriptive statistics

### Walkthrough bar plot

Plot self-reported emoji understanding by gender (male and female), relative frequencies, adjust color manually to colors of @fricke2024semantic:

```{r}

ggplot(gender_understanding_count, aes(x = emoji_understanding, y = percentage, fill = gender)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Self-reported Emoji Understanding by Gender",
       x = "Emoji understanding",
       y = "Percent") +
  scale_fill_manual(values=c("#003560", "#B61E3E"))

```

```{r match count}

data_without_fillers |> #simple barplot showing that matches occurred more often than no matches
  ggplot(aes(x = match)) +
  geom_bar()

match_count <- data_without_fillers |> 
  group_by(match) |> 
  count()

#   match     n
#   <chr>  <int>
# 1 no       583
# 2 yes     1325

```

```{r plot match x emoji use}

#trying to see whether there is a correlation of emoji use and matching accuracy
match_use_count <- data_without_fillers |> 
  group_by(match, emoji_use) |> 
  count()

match_use_count |> 
  group_by(emoji_use) |> 
  ggplot(aes(x = emoji_use, y = n, fill = match)) +
  geom_bar(stat = "identity", position = "dodge") + #better with position = "dodge" or default position = "stack"?
  labs(x = "Use frequency", y = "count")
#there seem to be considerable differences between values

match_use_count |> 
  ggplot(aes(x = emoji_use, y = n, fill = match)) + 
  geom_bar(stat = "identity", show.legend = TRUE, position = "fill") +
  scale_fill_brewer(palette="Set1")+
  labs(title = "Do participants that use emojis less frequently have a lower matching accuracy?",
       x = "Use frequency",
       y = "Ratio")+
  coord_flip()

#the plot does not really look meaningful, i.e. there is not a real difference when scaled up to 100%

```

```{r AU difference , matching rates, context}

perc_AU_diff <- data_without_fillers |> 
  group_by(context) |> 
  count(match) |> #counts matches and non-matches (match((yes/no)) for each context
  mutate(percent = round(n/sum(n)*100, 2)) #creates a new column with the percentages for each of the above counts (in relation to the sum of all matches/non-matches within each context, rounded to 2 digits)

```

Creating a stacked bar plot for the first (AU+) condition, emoji pair 😯 😲, contexts concern and surprise.

```{r}

plot_concern_surprise <- perc_AU_diff |> 
filter(context == "concern" | context == "surprise") |> 
ggplot(aes(x = context, y = percent, fill = match)) +
geom_bar(stat = "identity") +
scale_x_discrete(limits = c("concern", "surprise")) +
geom_text(aes(label = percent), position = position_stack(vjust = 0.5)) +
labs (x= "", y = "", title = "😯 😲") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))

plot_concern_surprise

```

Delete?

```{r}

# #happiness - (cheeky) laughter
# plot_happiness_cheeky <- perc_AU_diff |> 
# filter(context == "happiness" | context == "(cheeky) laughter") |> #happiness = general happiness
# ggplot(aes(x = context, y = percent, fill = match)) +
# geom_bar(stat = "identity") +
# scale_x_discrete(limits = c("happiness", "(cheeky) laughter")) +
# geom_text(aes(label = percent), position = position_stack(vjust = 0.5)) +
# labs(x = "", y = "", title = "😃 😆")+
# theme_minimal() +
# theme(plot.title = axis.text.x = element_text(size = 4.5), element_text(hjust = 0.5))
# 
# #mild irritation - annoyance
# plot_mild_irr_annoyance <- perc_AU_diff |> 
# filter(context == "mild irritation" | context == "annoyance") |> 
# ggplot(aes(x = context, y = percent, fill = match)) +
# geom_bar(stat = "identity") +
# scale_x_discrete(limits = c("mild irritation", "annoyance")) +
# geom_text(aes(label = percent), position = position_stack(vjust = 0.5)) +
# labs(x = "", y = "", title = "😐 😑") +
# theme_minimal() +
# theme(plot.title = element_text(hjust = 0.5))
# 
# #AU- condition:
# #mild disappointment - moderate disappointment
# plot_mild_disapp_mod_dissap <- perc_AU_diff |> 
# filter(context == "mild disappointment" | context == "moderate disappointment") |> 
# ggplot(aes(x = context, y = percent, fill = match)) +
# geom_bar(stat = "identity") +
# scale_x_discrete(limits = c("mild disappointment", "moderate disappointment")) +
# geom_text(aes(label = percent), position = position_stack(vjust = 0.5)) +
# labs(x = "", y = "", title = "🙁️ ☹️")+
# theme_minimal() +
# theme(plot.title = element_text(hjust = 0.5))
# 
# #amusement - (intense) happiness
# plot_amusement_int_happiness <- perc_AU_diff |> 
# filter(context == "amusement" | context == "(intense) happiness") |> #intense happiness = overhappy
# ggplot(aes(x = context, y = percent, fill = match)) +
# geom_bar(stat = "identity") +
# scale_x_discrete(limits = c("amusement", "(intense) happiness")) +
# geom_text(aes(label = percent), position = position_stack(vjust = 0.5)) +
# labs(x = "", y = "", title = "😄 😁") +
# theme_minimal() +
# theme(plot.title = element_text(hjust = 0.5))
# 
# #happiness2 - bashfulness
# plot_happiness2_bashfulness <- perc_AU_diff |> 
# filter(context == "happiness2" | context == "bashfulness") |>
# ggplot(aes(x = context, y = percent, fill = match)) +
# geom_bar(stat = "identity") +
# scale_x_discrete(limits = c("happiness2", "bashfulness")) +
# geom_text(aes(label = percent), position = position_stack(vjust = 0.5)) +
# labs(x = "", y = "", title = "😊 ☺️") + 
# theme_minimal() +
# theme(plot.title = element_text(hjust = 0.5))
# 
# #arrange all AU+ conditions together in one plot
# AU_plus <- ggarrange(plot_concern_surprise, plot_happiness_cheeky, plot_mild_irr_annoyance,
# #labels = "AU+ condition",
# common.legend = TRUE, legend = "right",
# nrow = 1, ncol = 3)
# 
# AU_plus <- annotate_figure(AU_plus,
# left = text_grob("[AU+] condition", rot = 90))
# 
# #arrange all AU-conditions together in one plot
# AU_minus <- ggarrange(plot_mild_disapp_mod_dissap, plot_amusement_int_happiness, plot_happiness2_bashfulness,
# #labels = "AU- condition",
# common.legend = TRUE, legend = "right",
# nrow = 1, ncol = 3)
# 
# AU_minus <- annotate_figure(AU_minus,
# left = text_grob("[AU-] condition", rot = 90))
# 
# AU_combined <- ggarrange(AU_plus, AU_minus,
# nrow = 2)
# 
# AU_combined <- annotate_figure(AU_combined, #also a function of the "ggpubr" package
# #top = text_grob("AU differences for individual contexts"),
# #left = text_grob("percent", rot = 90),
# bottom = text_grob("context"))
# 
# AU_combined

```

Since we have to do this with all emoji pairs, we define a function.

```{r}

plot_AU_matches <- function(contexts, emojis) {
  perc_AU_diff |> 
    filter(context %in% contexts) |> 
    ggplot(aes(x = context, y = percent, fill = match)) +
    geom_bar(stat = "identity") +
    scale_x_discrete(limits = contexts) +
    geom_text(aes(label = percent), position = position_stack(vjust = 0.5)) +
    labs (x= "", y = "", title = emojis) +
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5))
}

```

##### Question for Elen 3/6

Would it be better to use geom_col instead of geom_bar(stat = "identity"), since the two are seemingly identical? Or is unnecessarily more complicated for the textbook readers?

##### Question for Elen 4/6

Is it too advanced to define a function to create the plot? Instead, we could write out the code as above under "Delete" but a lot of it would be redundant.

We apply this function to all emoji pairs and contexts.

```{r}

plot_concern_surprise <- plot_AU_matches(c("concern", "surprise"), "😯 😲")
plot_happiness_cheeky <- plot_AU_matches(c("happiness", "(cheeky) laughter"), "😃 😆")
plot_mild_irr_annoyance <- plot_AU_matches(c("mild irritation", "annoyance"), "😐 😑")
plot_mild_disapp_mod_dissap <- plot_AU_matches(c("mild disappointment", "moderate disappointment"), "🙁️ ☹️")
plot_amusement_int_happiness <- plot_AU_matches(c("amusement", "(intense) happiness"), "😄 😁")
plot_happiness2_bashfulness <- plot_AU_matches(c("happiness2", "bashfulness"), "😊 ☺️")

```

Arranging all AU+ conditions together in one plot, arranging all AU- conditions together in one plot.

```{r}

AU_plus <- ggarrange(plot_concern_surprise, plot_happiness_cheeky, plot_mild_irr_annoyance,
#labels = "AU+ condition",
common.legend = TRUE, legend = "right",
nrow = 1, ncol = 3)

AU_plus <- annotate_figure(AU_plus,
left = text_grob("[AU+] condition", rot = 90))

AU_minus <- ggarrange(plot_mild_disapp_mod_dissap, plot_amusement_int_happiness, plot_happiness2_bashfulness,
#labels = "AU- condition",
common.legend = TRUE, legend = "right",
nrow = 1, ncol = 3)

AU_minus <- annotate_figure(AU_minus,
left = text_grob("[AU-] condition", rot = 90))

```

Combining all AU+ and AU- plots.

```{r}

AU_combined <- ggarrange(AU_plus, AU_minus,
nrow = 2)

AU_combined <- annotate_figure(AU_combined, #also a function of the "ggpubr" package
#top = text_grob("AU differences for individual contexts"),
#left = text_grob("percent", rot = 90),
bottom = text_grob("context"))

AU_combined

```

```{r}

ggsave(filename = "images/AU_plot.png", width = 3400, height = 2000, units = "px")

```

##### Question for Elen 5/6

The plot came out looking quite similar to the one of Fricke et al (p. 11). We were wondering whether that similarity is okay?

##### Question for Elen 6/6

The easiest way to display the plot is by saving it using ggsave and inserting it as an image. Otherwise the long context labels on the x axis would always overlap. This solution felt not ideal to us because changing the code then does not immediately transfer to the plot in the html output. Another solution would be to make the font of the labels very small so that they do not overlap. However, since that messes with the proportions within the plot, we both prefer the ggsave Version. So we would like to know whether using ggsave is acceptable in this case.

![Individual context differences for AU conditions](images/AU_plot.png)

::: callout-tip
#### Quiz time! {.unnumbered}

1\) Test question?

```{r echo=FALSE, results="asis"}

check_question("D", options = c("A", "B", "C", "D", "E"), type = "radio", 
random_answer_order = TRUE,
button_label = "Check answer", q_id = 4,
right = "Test right!",
wrong = "Test incorrect.")

```
:::

## Conclusion

## References
