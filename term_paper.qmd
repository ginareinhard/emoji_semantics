---
title: "Term paper"
subtitle: ""
author: "Rose Hörsting & Gina Reinhard"
date: "2024-09-15"
engine: knitr
bibliography: references.bib
format: 
  html:
    toc: true
    toc-depth: 3
    number-sections: true
    embed-resources: true
    fig-width: 10
    fig-height: 8
link-citations: true
csl: "apa_7th.csl"
---

```{r ragg, include=FALSE}

#install.packages("ragg")
library(ragg)

```

```{r setup, include=FALSE}

knitr::opts_chunk$set(dev = "ragg_png")

```

```{r include=FALSE}

library(checkdown)

```

#### **Chapter overview** {.unnumbered}

In this chapter, we...

## Session set up

```{r load-libraries, message=FALSE}

library(here)
library(tidyverse)
#install.packages("ggpubr")
library(ggpubr)
#install.packages("scales")
library(scales)
#install.packages(patchwork)
library(patchwork)

```

## Introducing the study

@fricke2024semantic \> Fricke, L., Grosz, P. G., & Scheffler, T. (2024). Semantic differences in visually similar face emojis. Language and Cognition, 1–15. \<httpsdoi:10.1017/langcog.2024.12\>.

::: {.callout-note title="How did the experiment work?"}
...

They used the face emoji annotation system developed by @fugate2021implications, Facial Action Coding System (FACS) by @ekman1978facial. FACS decomposes facial expressions into minimal Action Units (AUs) which makes the annotation of face emojis possible.

Pictorial approach @maier2023emojis vs. lexicalist approach @grosz2023semantics.

Goal: Test the predictions of the pictorial approach, i.e.: There should be a clear preference for the context-matching emoji for emoji pairs with an \[AU+\] difference. For emojis without an AU difference \[AU-\], context-matching emojis should be chosen less often (p.7)

Question: Do AU differences lead to differences in meaning between the two emojis of a pair? Hypothesis: "Small visual differences that do not correspond to AU differences ((no clear real-life counterparts)) should be semantically less relevant than visual differences that do correspond to AU differences" (4) Method: three \[AU+\] and three \[AU\] emoji pairs, rendered in WhatsApp Android version; each emoji to occur on one pair; no emojis with symbolic components (5) Task: participants must choose between emojis of a pair (Forced choce task), help "Alex/Anna" help using the emoji that best matches the text (6)
:::

![Image from @fricke2024semantic](images/emoji_pairs.png){#fig-emojipairs fig-align="center"}

![Image from @fricke2024semantic](images/emoji_use.png){#fig-emojiuse fig-align="center" width="500"}

![Image from @fricke2024semantic](images/emoji_attitude.png){#fig-emojiattitude fig-align="center" width="500"}

## Inserting emojis in R

(move this chapter/subchapter?)

Insert emojis via emoji keyboard (Shortcut fn+e on Mac), also available in R Studio (Edit -\> Emojis & Symbols). This is the easiest way. Alternatively, there are emoji libraries, e.g. "emo(ji)" (<https://github.com/hadley/emo>).

As we want to display emojis within plots using ggplot: We have to use AGG/Cairo? as Backend in R Studio (Tools -\> Global Options -\> Graphics -\> Backend -\> AGG) \[explain AGG/Cairo\]. Only necessary for Mac?

For rendering the output from qmd (or Markdown?) to HTML (or pdf?) we can:

-   save the plots with ggsave() and insert them
-   use the ragg library (<https://ragg.r-lib.org>) ("ragg can be used as the graphic back-end to the RStudio device (for RStudio \>= 1.4) by choosing *AGG* as the backend in the graphics pane in general options (see screenshot)")

## Data wrangling

Import the data using "here":

```{r import-data, message=FALSE}

raw_data <- read.csv(file = here("data", "raw_data.csv"))

```

Filter out participants who exceed the maximum age of 35 years specified by @fricke2024semantic (p. 8):

```{r clean-data}

data <- raw_data |> 
  filter(age <= 35)

```

## Data analysis/visualisation

### Descriptive statistics

## Explore the relationship between gender and emoji understanding

```{r}

data <- data |> 
  mutate(gender = recode(gender, "männlich" = "men", "weiblich" = "women")) |>
    mutate(emoji_understanding = recode(emoji_understanding, "mittelmäßig" = "moderate", "eher gut" = "rather good", "gut" = "good", "sehr gut" = "very good")) |>
    mutate(emoji_understanding = factor(emoji_understanding, levels = c("moderate", "rather good", "good", "very good")))

```

Let's first get a general overview of the gender distribution in the data. This is not straightforward, as the data frame contains 24 rows for each subject. So if we were to simply count the occurrences of ‘men’, ‘women’, and ‘non-binary’ in the data, we would end up with 24 times the values of the frequencies.

To determine the actual gender distribution, we need to group the data according to the subjects' unique IDs. To do this, we apply the `group_by` function to the `submission_id` variable. We then pipe `count(gender)` to this to count the genders by `submission_id`. (refer to <https://elenlefoll.github.io/RstatsTextbook/7_VariablesFunctions.html> **7.5.2 Piped Functions**).

```{r}

gender_count <- data |> 
  group_by(submission_id) |> 
  count(gender)

```

The result is stored in a new data frame called 'gender_count'. Now we can look at the distribution using the `table()` function:

```{r}

table(gender_count$gender)

```

Alternatively, we can use the `distinct()` function to keep only unique occurrences (exactly: the first unique occurrence) of each submission_id. The argument `.keep_all` is set to `TRUE`, which means that all other variables in the data frame are kept and not deleted:

```{r}

gender_count <- data |> 
  distinct(submission_id, .keep_all = TRUE)

table(gender_count$gender)

```

The gender distribution is very uneven: 109 men, 47 women, and 3 non-binary people participated in the study.

The uneven gender distribution (/this) is likely to skew our visualisation. To solve this problem, we will, like @fricke2024semantic, use relative rather than absolute frequencies and exclude the very small group of three non-binary participants. (move this part?)

Next, we want to find out how well the different gender groups report to understand emojis. To do this, we create a new data frame ‘gender_emoji_count’ and again only keep the unique submission_id. We group the data by gender and count the frequencies for the different gender groups within the emoji_understanding variable:

```{r}

gender_understanding_count <- data |>
  distinct(submission_id, .keep_all = TRUE) |> 
  group_by(gender) |> 
  count(gender, emoji_understanding)

```

Add relative frequencies:

```{r}

gender_understanding_count <- data |>
  distinct(submission_id, .keep_all = TRUE) |> 
  group_by(gender) |> 
  count(gender, emoji_understanding) |> 
  mutate(total = sum(n), 
         percentage = (n/total) * 100)

```

Print the results:

```{r}

gender_understanding_count <- gender_understanding_count |> 
  select(gender, emoji_understanding, n, percentage)

print(gender_understanding_count)

```

### Walkthrough bar plot

```{r}

gender_understanding_count <- gender_understanding_count |> 
  filter(gender != "divers")

```

Plot self-reported emoji understanding by gender (male and female), relative frequencies, adjust color manually to colors of @fricke2024semantic:

```{r}

ggplot(gender_understanding_count, aes(x = emoji_understanding, y = percentage, fill = gender)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Self-reported Emoji Understanding by Gender",
       x = "Emoji understanding",
       y = "Percent") #+
  #scale_fill_manual(values=c("#003560", "#B61E3E"))

```

### Emoji use

```{r match count}

# match_count <- data |> 
#   group_by(match) |> 
#   count()

#   match     n
#   <chr>  <int>
# 1 no       583
# 2 yes     1325

```

```{r plot match x emoji use}

# #trying to see whether there is a correlation of emoji use and matching accuracy
# match_use_count <- data |> 
#   group_by(match, emoji_use) |> 
#   count()
# 
# match_use_count |> 
#   group_by(emoji_use) |> 
#   ggplot(aes(x = emoji_use, y = n, fill = match)) +
#   geom_bar(stat = "identity", position = "dodge") + #better with position = "dodge" or default position = "stack"?
#   labs(x = "Use frequency", y = "count")
# #there seem to be considerable differences between values
# 
# match_use_count |> 
#   ggplot(aes(x = emoji_use, y = n, fill = match)) + 
#   geom_bar(stat = "identity", show.legend = TRUE, position = "fill") +
#   scale_fill_brewer(palette="Set1")+
#   labs(title = "Do participants that use emojis less frequently have a lower matching accuracy?",
#        x = "Use frequency",
#        y = "Ratio")+
#   coord_flip()

#the plot does not really look meaningful, i.e. there is not a real difference when scaled up to 100%

```

## AU plot

Create a column with the experimental conditions (AU+, AU-, and filler/control items) using a combination of str_detect, case_when and mutate:

```{r}

#delete this code chunk?

data <- data |>
  mutate(AU_difference = case_when(str_detect(name, "AU") ~ "yes",
                                   str_detect(name, "N") ~ "no",
                                   str_detect(name, "filler") ~ "filler",
                                   .default = NULL))

table(data$AU_difference)

```

Filter out filler emojis:

```{r}

data <- data |>
  filter(AU_difference != "filler")

# alternative (if code chunk above is deleted): 
#data <- data |> 
#  filter(!str_detect(name, "filler"))

```

Define contexts using a combination of str_detect, case_when and mutate (and check output with table()):

```{r}

data <- data |> 
  mutate(context = case_when(str_detect(question, "freut sich") ~ "happiness", #Fricke et al.: general happiness
                             str_detect(question, "lacht") ~ "(cheeky) laughter", #hearty laughter 

                             str_detect(question, "macht sich Sorgen") ~ "concern",
                             str_detect(question, "ist überrascht") ~ "surprise",
                             str_detect(question, "ist etwas genervt") ~ "mild irritation",
                             str_detect(question, "ärgert sich") ~ "annoyance",
                             str_detect(question, "amüsiert sich") ~ "amusement",
                             str_detect(question, "ist überglücklich") ~ "(intense) happiness", #overhappy
                             str_detect(question, "ist enttäuscht") ~ "mild disappointment",
                             #str_detect(question, "ist enttäuscht") ~ "moderate disappointment",
                             str_detect(question, "ist gut gelaunt") ~ "happiness2", #called this "happiness2" for now, Fricke et al.: happiness
                             str_detect(question, "ist verlegen") ~ "bashfulness",
                                   .default = NULL))

table(data$context)

```

Problem: emoji pair "slightly frowning face" and "frowning face" with the same question/context "ist enttäuscht". This is only resolvable using/citing the information from the original analysis script? (meaning of N-36 = "mild disappointment", meaning of N-37 = "moderate disappointment")

```{r}

data <- data |> 
  mutate(context = case_when(
                             str_detect(name, "N-36") ~ "mild disappointment",
                             str_detect(name, "N-37") ~ "moderate disappointment",
                                   .default = context))

table(data$context)

```

Define matches:

```{r}

data <- data |> 
  mutate(
  match = case_when( #called it match for now, potentially the only match column needed?
    context == "happiness" & response == "grinning_face_with_big_eyes" ~ "yes",
    context == "(cheeky) laughter" & response == "grinning_squinting_face" ~ "yes",
    context == "concern" & response == "hushed_face" ~ "yes",
    context == "surprise" & response == "astonished_face" ~ "yes",
    context == "mild irritation" & response == "neutral_face" ~ "yes",
    context == "annoyance" & response == "expressionless_face" ~ "yes",
    context == "amusement" & response == "grinning_face_with_smiling_eyes" ~ "yes",
    context == "(intense) happiness" & response == "beaming_face_with_smiling_eyes" ~ "yes",
    context == "mild disappointment" & response == "slightly_frowning_face" ~ "yes",
    context == "moderate disappointment" & response == "frowning_face" ~ "yes",
    context == "happiness2" & response == "smiling_face_with_smiling_eyes" ~ "yes",
    context == "bashfulness" & response == "smiling_face" ~ "yes",
    .default = "no"))

```

```{r AU difference , matching rates, context}

perc_AU_diff <- data |> 
  group_by(context) |> 
  count(match) |> #counts matches and non-matches (match((yes/no)) for each context
  mutate(percent = round(n/sum(n)*100, 2)) #creates a new column with the percentages for each of the above counts (in relation to the sum of all matches/non-matches within each context, rounded to 2 digits)

```

Creating a stacked bar plot for the first (AU+) condition, emoji pair 😯 😲, contexts concern and surprise.

```{r}

plot_concern_surprise <- perc_AU_diff |> 
filter(context == "concern" | context == "surprise") |> 
ggplot(aes(x = context, y = percent, fill = match)) +
geom_bar(stat = "identity") +
scale_x_discrete(limits = c("concern", "surprise")) +
geom_text(aes(label = percent), position = position_stack(vjust = 0.5)) +
labs (x= "", y = "", title = "😯 😲") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))

plot_concern_surprise

```

Since we have to do this with all emoji pairs, we define a function.

```{r}

plot_AU_matches <- function(contexts, emojis) {
  perc_AU_diff |> 
    filter(context %in% contexts) |> 
    ggplot(aes(x = context, y = percent, fill = match)) +
    geom_col() +
    scale_x_discrete(limits = contexts) +
    geom_text(aes(label = percent), position = position_stack(vjust = 0.5)) +
    labs (x= "context", y = "percent", title = emojis) +
    theme_bw() +
    theme(plot.title = element_text(hjust = 0.5))
}

```

We apply this function to all emoji pairs and contexts.

```{r}

plot_concern_surprise <- plot_AU_matches(c("concern", "surprise"), "😯 😲")
plot_happiness_cheeky <- plot_AU_matches(c("happiness", "(cheeky) laughter"), "😃 😆")
plot_mild_irr_annoyance <- plot_AU_matches(c("mild irritation", "annoyance"), "😐 😑")
plot_mild_disapp_mod_dissap <- plot_AU_matches(c("mild disappointment", "moderate disappointment"), "🙁️ ☹️")
plot_amusement_int_happiness <- plot_AU_matches(c("amusement", "(intense) happiness"), "😄 😁")
plot_happiness2_bashfulness <- plot_AU_matches(c("happiness2", "bashfulness"), "😊 ☺️")

```

### ggarrange

Arranging all AU+ conditions together in one plot, arranging all AU- conditions together in one plot.

```{r}

AU_plus <- ggarrange(plot_concern_surprise, plot_happiness_cheeky, plot_mild_irr_annoyance,
#labels = "AU+ condition",
common.legend = TRUE, legend = "right",
nrow = 3, ncol = 1)

AU_plus <- annotate_figure(AU_plus,
top = text_grob("[AU+] condition"))

AU_minus <- ggarrange(plot_mild_disapp_mod_dissap, plot_amusement_int_happiness, plot_happiness2_bashfulness,
#labels = "AU- condition",
common.legend = TRUE, legend = "right",
nrow = 3, ncol = 1)

AU_minus <- annotate_figure(AU_minus,
top = text_grob("[AU-] condition"))

```

Combining the AU+ and AU- plots.

```{r}

AU_combined <- ggarrange(AU_plus, AU_minus,
ncol = 2)

# AU_combined <- annotate_figure(AU_combined, #also a function of the "ggpubr" package
# #top = text_grob("AU differences for individual contexts"),
# #left = text_grob("percent", rot = 90),
# bottom = text_grob("context"))

AU_combined

```

```{r}

ggsave(filename = "images/AU_plot.png", width = 3400, height = 2000, units = "px")

```

### Patchwork

By applying our function `plot_AU_matches` to all emoji pairs and contexts, we have created one barplot for each emoji pair. We will use the `patchwork` package (@pedersen2024patchwork) to assemble the plots in an overview. As the name suggests, the `patchwork` package enables us to patch several plots together and arrange them nicely, so that the finished graph will be cohesive and informative.

![Patchwork artwork by Allison Horst](images/patchwork.png)

#### Version 1

In line with the research question of @fricke2024semantic, we want to compare the matching rates of emojis and contexts in the \[AU+\] condition with the matching rates in the \[AU-\] condition. In the `patchwork` package, plots are combined by `|` (horizontally), `/` (vertically), or `+` (generally).

First, let us plan the layout of our final graph with some placeholder names:
```
p1 <- x / y / z

p2 <- a / b / c

p_combined <- p1 | p2

```
In each of the patchworks `p1` and `p2`, three plots are stacked on top of each other. These will be the plots of the \[AU+\] condition and the \[AU-\] condition. We will then put these patchworks next to each other for comparison (`p_combined`). The final graph will have two columns and three rows.

Now, we simply need to fill in the names of the plots and choose some meaningful names:

```{r}
#[AU+] condition:
AU_plus_patch <- 
  plot_concern_surprise / plot_happiness_cheeky / plot_mild_irr_annoyance

#[AU-] condition:
AU_minus_patch <- 
  plot_mild_disapp_mod_dissap / plot_amusement_int_happiness / plot_happiness2_bashfulness
```

The `plot_layout` function takes the argument `guides`. By setting this argument to `"collect"`, identical legends of all plots within the patchwork are merged.

```{r}
#AU+ condition:
AU_plus_patch <- AU_plus_patch +
  plot_layout(guides = "collect")

#AU- condition:
AU_minus_patch <- AU_minus_patch +
  plot_layout(guides = "collect")
```

Since `AU_plus_patch` and `AU_minus_patch` are to be combined in one graph, we need to add titles to them to keep them apart. Technically, it is possible (and recommended!) to use the `plot_annotation` function of the `patchwork` package for this. However, annotations of this function are only shown at the highest nesting level. As we will be building a double-nested plot, any annotations we do on the "blocks-of-three"-level will not be displayed. We can work around this by using the function `wrap_elements`. This fixates the blocks in their current state and allows us to add titles in the form of `ggtitles` which relate the blocks to the conditions. Unfortunately, there is one small downside to this approach, as we will see in a second.

```{r}
AU_plus_patch <- wrap_elements(plot = AU_plus_patch) +
  ggtitle("[AU+] condition")

AU_minus_patch <- wrap_elements(plot = AU_minus_patch) +
  ggtitle("[AU-] condition")
```

Finally, we put both elements together to get our final graph.

```{r}
AU_combined_patch1 <- AU_plus_patch | AU_minus_patch

AU_combined_patch1
```

This graph contains information on the matching rates of all emoji pairs with their contexts. However, you will probably notice that the graph contains two identical legends. This is not ideal but it is the trade-off we take by using the `wrap_elements` function: We have fixated the patchworks in their state with their legends, therefore the legends cannot be merged later. There are a couple of other options that will produce other outcomes, however, none is going to be perfect.

The options are to (1) delete the legends from both blocks, (2) keep the legend of one block and delete the other (this makes the bars take up the space of the legend, i.e. the bars in one block become wider than in the other one), or (3) keep the legends of all six plots. We have opted to create one legend for each condition, but feel free to try the other options for yourself and see how it affects the final product.

As you have now experienced, building plots and assembling them can be quite fiddly. You may get lost in details and may need to accept some trade-offs. It can take some time and a lot of trial-and-error to make the final plot look like what you have imagined. However, there is a solution for (almost) anything and hopefully, the beautiful graph you create in the process will make up for the trouble.

::: callout-tip
#### Quiz time! {.unnumbered}

[**Q1.**]{style="color:green;"} Looking at the final patchwork, which "sub-plot" shows the most significant finding?

```{r echo=FALSE, results="asis"}

check_question("lower left", options = c("upper left", "upper right", "middle left", "middle right", "lower left", "lower right"), type = "radio", 
random_answer_order = TRUE,
button_label = "Check answer", q_id = 5,
right = "That´s right! There is a notable difference between the matching rates.",
wrong = "Not quite, try again.")
```





[**Q2.**]{style="color:green;"} Which interpretation of this finding is most accurate?
:::

#### Version 2

Alternative: create a plot without nesting before, so with all six plots. Problem: no other possibility to create "AU titles" other than adding the labels as separate objects.

```{r}
col_label1 <- wrap_elements(panel = text_grob("AU+ condition"))
col_label2 <- wrap_elements(panel = text_grob("AU- condition"))

AU_combined_patch2 <- 
  ((col_label1 / plot_concern_surprise / plot_happiness_cheeky / plot_mild_irr_annoyance) | (col_label2 / plot_mild_disapp_mod_dissap / plot_amusement_int_happiness / plot_happiness2_bashfulness)) +
  plot_layout(heights = c(.1,2,2,2,.2,2,2,2), guides = "collect") &
  theme(legend.position = "bottom")
 
AU_combined_patch2
#problem: a lot of white space around the condition labels

```

::: callout-tip
#### Quiz time! {.unnumbered}

1\) Test question?

```{r echo=FALSE, results="asis"}

check_question("D", options = c("A", "B", "C", "D", "E"), type = "radio", 
random_answer_order = TRUE,
button_label = "Check answer", q_id = 4,
right = "Test right!",
wrong = "Test incorrect.")

```
:::

## Conclusion

## References
