---
title: "Exploring the semantics of emojis: analysis and visualisation of categorical data"
subtitle: ""
author: "Rose H√∂rsting & Gina Reinhard"
date: "2024-09-12"
engine: knitr
bibliography: references.bib
format: 
  html:
    df-print: default
    toc: true
    toc-depth: 3
    fig-width: 10
    fig-height: 8
    number-sections: true
    embed-resources: true
link-citations: true
csl: "apa_7th.csl"
number-sections: true
---

```{=html}
<style>
p {
  text-align: justify;
}
</style>
```
```{r setup, include=FALSE}

knitr::opts_chunk$set(dev = "ragg_png", warning = FALSE, message = FALSE)

```

```{r checkdown, include=FALSE}

library(checkdown)

```

::: callout-warning
### Session set up {#sec-session-set-up}

To run the code of this chapter, you will need to install and load the following packages:

```{r load-libraries, message=FALSE}

library(here)
library(tidyverse)
#install.packages("patchwork")
library(patchwork)
#install.packages("ragg")
library(ragg)

```

```{r colour-palettes, include=FALSE}

# colourblind-friendly
# https://www.datanovia.com/en/blog/top-r-color-palettes-to-know-for-great-data-visualization/#r-base-color-palettes

cbp1 <- c("#999999", "#E69F00", "#56B4E9", "#009E73",
          "#F0E442", "#0072B2", "#D55E00", "#CC79A7")

# another option with an additional package:
#install.packages("RColorBrewer")
library(RColorBrewer)
display.brewer.all(colorblindFriendly = TRUE)
brewer.pal(2, "Set2")
# second list of colours is best suited for nominal/categorical data: "Set2", "Paired", "Dark2"

```
:::

#### **Chapter overview** {#sec-chapter-overview .unnumbered}

The chapter will walk you through:

-   overviewing and exploring the data of a study
-   preprocessing data for analysis (including translation, ordering and categorisation of levels)
-   analysing and interpreting frequencies of categorical variables
-   visualising frequencies using a barplot
-   inserting and displaying emojis in R and inside of plots
-   assembling multiple plots into a patchwork and interpreting it

We will work with the data from this study by @fricke2024semantic:

> Fricke, L., Grosz, P. G., & Scheffler, T. (2024). Semantic differences in visually similar face emojis. Language and Cognition, 1‚Äì15. <https://doi.org/10.1017/langcog.2024.12>

@fricke2024semantic have made their data and their analysis code publicly available. You can access it at <https://osf.io/k2t9p/>. The data is contained in the file `raw_data.csv`.

## Introducing the study {#sec-introducing-the-study}

Face emojis stand in for facial expressions and thereby fundamentally contribute to the subtext of a text message. A few studies have investigated the relationship between emojis and the emotions they depict. However, as emojis are a relatively recently occuring phenomenon, there is still a lot to be discovered. In this chapter, we will look into the study by @fricke2024semantic.

### Deconstructing emojis into Action Units {#sec-deconstructing}

@fricke2024semantic compared visually similar emojis using a face emoji annotation system developed by @fugate2021implications. This annotation system is based on the Facial Action Coding System (FACS) for human faces invented by @ekman1978facial. @fricke2024semantic assigned numbers to human-like facial features such as *eyebrows arched* and *eyes wide*. These numbers are called Action Units, short AUs. As you can see in @fig-emojipairs, each emoji consists of several AUs:

![Emoji pairs and their contexts [@fricke2024semantic, p.5]](images/emoji_pairs.png){#fig-emojipairs fig-align="center" width="700"}

@fricke2024semantic defined two different types of emoji pairs: In the AU+ condition, the visual difference between emojis corresponded to a difference between AUs. In the AU- condition, the visual difference did not correspond to an AU difference.

### The experiment {#sec-design}

::: {.callout-note title="How did the experiment work?"}
Three AU+ and three AU- emoji pairs were created (see @fig-emojipairs). Each pair was assigned two contexts, with each context corresponding to the prominent usage or meaning of one emoji but not the other. For example, the contexts of the first pair are *happiness* and *(cheeky) laughter*. The contexts were assigned based on <https://emojipedia.org> and a previous norming study.

Four single-sentence narratives were created for each of the contexts. For an example, see @fig-testitems, translated from German below [taken from @fricke2024semantic, p.6]:

> 1.  Alex writes to his best friend Stefan:
>
>     *I just learned that my cousin's dog has his own advent calender.*
>
>     Alex is amused. Which of the emojis matches the message better? üòÑüòÅ
>
>     <br>
>
> 2.  Alex writes to his best friend Stefan:
>
>     *I just learned that I won 500 Euro in the lottery.*
>
>     Alex is overjoyed. Which of the emojis matches the message better? üòÑüòÅ

These stories were divided up into into four experimental lists of 12 items. Each list also contained 12 filler items, so that each participant saw 24 items. The participants were then asked to help choose the emoji that matched the context. Each participant saw each emoji pair twice. The rate with which the context-matching emoji was chosen was measured.
:::

![Example of a test item in @fricke2024semantic's experiment [@fricke2024semantic, p.6]](images/test_items.png){#fig-testitems fig-align="center" width="500"}

@fricke2024semantic's central research question was: **Do AU differences lead to differences in meaning between the two emojis of a pair?** In line with the pictorial approach by @maier2023emojis, they predicted that small visual differences between emojis which correspond to human facial features (AU+) would be more semantically relevant compared to those that do not (AU-).

::: callout-tip
#### Quiz time! {.unnumbered}

[**Q1.**]{style="color:green;"} According to @fricke2024semantic's hypothesis, which of these results would you expect from the experiment?

```{r echo=FALSE, results="asis"}

check_question(c("Participants will choose the context-matching emoji more often in the AU+ condition.", "For the AU- pairs, the pattern will be more random."), options = c("Participants will choose the context-matching emoji more often in the AU+ condition.", "For the AU- pairs, the pattern will be more random.", "Participants will choose the context-matching emoji more often in the AU- condition.", "For the AU+ pairs, the pattern will be more random.", "For both types of pairs, the context-matching emoji will be preferred over the non-matching one."), type = "checkbox",
random_answer_order = TRUE,
button_label = "Check answer",
right = "That's right! Visual differences between emojis would be semantically more relevant if they correspond to differences in human facial features (AU+). This would lead to participants choosing a context-matching emoji more often in the AU+ condition and making more random choices in the AU- condition.",
wrong = "Not quite. Try again.")
check_hint("Based on the hypothesis, differences corresponding to facial features (AU+) would be more semantically relevant. In contrast, differences  that do not correspond to facial features (AU-) would be less semantically relevant, making them less noticeable and leading to more inconsistent choices. How might this affect the frequency with which participants choose the context-matching emoji in each condition?", hint_title = "üê≠ Click on the mouse for a hint.")

```

<br>
:::

## Exploring the relationship between gender and emoji understanding {#sec-gender-understanding}

@fricke2024semantic asked participants about their gender, their attitude towards emojis, how often they use emojis on WhatsApp and how well they think they understand emojis. They visualised the distribution of male and female gender for emoji use and emoji attitude as barplots:

::: {#fig-barplots layout-ncol="2"}
![Barplot "Emoji use by gender"](images/emoji_use.png){#fig-emojiuse fig-align="center" width="550"}

![Barplot "Attitude towards emojis by gender"](images/emoji_attitude.png){#fig-emojiattitude fig-align="center" width="550"}

Barplots from @fricke2024semantic (p. 9 and p. 10)
:::

The plots in @fig-barplots show that women use emojis more often and have a more positive attitude towards emojis than men. We want to find out whether women also reported a higher level of emoji understanding than men. Our analysis will involve 3 steps:

1.  calculating the frequencies of the genders in the data\
2.  calculating the frequencies of the different levels of emoji understanding for each gender\
3.  visualising the frequencies in a barplot similar to the plots above

### Importing the data {#sec-importing-the-data}

Before we start our analysis, we import the data using the `here` function (see <https://elenlefoll.github.io/RstatsTextbook/6_ImpoRtingData.html> **6.5 Importing data from a .csv file**):

```{r import-data, message=FALSE}

raw_data <- read.csv(file = here("data", "raw_data.csv"))

```

As specified by @fricke2024semantic, we filter out participants who exceed the maximum age of 35 years for all following analyses. We do this by using the function `filter()` and store the result in a new data frame called `data`:

```{r filter-age}

data <- raw_data |> 
  filter(age <= 35)

```

### Gender frequency analysis {#sec-gender-freq}

Let's first get a general overview: How many men, women, and non-binary people participated in the study?

The relevant variable in the data set is called `gender`. However, you will see that the names of the different gender groups are in German. Before we start analysing, we should translate them into English. To figure out what the the labels of the different gender **levels** are, we use the `levels()` function. `levels()` applies to **factors**, so we first need to convert `gender` with the function `as.factor()`:

```{r convert-gender}

data$gender <- as.factor(data$gender)

```

Now, we can look at the levels of our factor `gender`:

```{r gender-levels}

levels(data$gender)

```

Using a combination of `mutate()` and `recode()`, we translate *m√§nnlich* to *men*, *weiblich* to *women*, and *divers* to *non-binary*:

```{r recode-gender}

data <- data |> 
  mutate(gender = recode(gender, 
                         "m√§nnlich" = "men", 
                         "weiblich" = "women", 
                         "divers" = "non-binary"))

levels(data$gender)

```

Now that the genders have English names, we want to determine how many men, women, and non-binary subjects participated. This is not straightforward, because the data frame contains 24 rows for each subject, as each participant saw 24 items (see @sec-design). If we were to simply count the occurrences of *men*, *women*, and *non-binary* in the data, we would end up with 24 times the values of the frequencies.

To determine the actual gender distribution, we need to group the data according to the subjects' unique IDs. To do this, we apply the `group_by` function to the `submission_id` variable. We then pipe `count(gender)` to this to count the genders by `submission_id`:

```{r gender-freq}

gender_count <- data |> 
  group_by(submission_id) |> 
  count(gender)

```

The result is stored in a new data frame called `gender_count`. Now we can look at the distribution using the `table()` function:

```{r gender-table}

table(gender_count$gender)

```

Alternatively, we can use the `distinct()` function to keep only unique occurrences (exactly: the first unique occurrence) of each `submission_id`. The argument `.keep_all` is set to `TRUE`, which means that all other variables in the data frame are kept and not deleted:

```{r gender-distinct}

gender_count <- data |> 
  distinct(submission_id, .keep_all = TRUE)

table(gender_count$gender)

```

The **mode** (see <https://elenlefoll.github.io/RstatsTextbook/8_DescriptiveStats.html> **8.1.3 Mode**) of the `gender` variable in the dataset is *men*, as you can see from the output. The gender distribution is very uneven: 109 men, 47 women, and 3 non-binary people participated in the study. This is likely to skew our visualisation.

::: callout-tip
#### Quiz time! {.unnumbered}

[**Q2.**]{style="color:green;"} Which of these problems are likely to occur if we plot emoji understanding by gender in a barplot with unequal group sizes?

```{r echo=FALSE, results="asis"}

check_question(c("It may appear as if men have a greater emoji understanding simply because of their group size.", "It may appear as if non-binary people have a lower emoji understanding simply because of their group size.", "The differences in emoji understanding between gender groups may look bigger than they actually are.", "With a very small sample size of 3 non-binary participants, the results may be unreliable."), options = c("It may appear as if men have a greater emoji understanding simply because of their group size.", "The differences in emoji understanding between gender groups may look bigger than they actually are.", "The differences in emoji understanding within gender groups may look smaller than they actually are.", "It may appear as if non-binary people have a lower emoji understanding simply because of their group size.", "There will be no problems if we use ggplot.", "With a very small sample size of 3 non-binary participants, the results may be unreliable."), type = "checkbox",
random_answer_order = TRUE,
button_label = "Check answer",
right = "That¬¥s right! Unequal group sizes can exaggerate the differences by showing larger totals for larger groups and smaller totals for smaller groups. With a small sample size, the results may also not be statistically significant and therefore unreliable.<br><br>Can you think of ways to address these issues?",
wrong = "Not quite. Try again.")
check_hint("Four of these problems are likely to occur.", hint_title = "üê≠ Click on the mouse for a hint.")

```

<br>
:::

To solve these problems, we will use the same strategies as @fricke2024semantic. We will use relative rather than absolute frequencies to make sure that the numbers for the different genders are comparable. For our visualisation, we will have to exclude the very small group of three non-binary participants.

### How well do the different genders understand emojis? {#sec-gender-understanding-freq}

Next, we calculate the relative frequencies of the different levels of emoji understanding for each gender.

The variable we are interested in is called `emoji_understanding`. Just like with `gender`, we first have to do some data wrangling. We convert `emoji_understanding` as a factor to get its levels:

```{r convert-understanding}

data$emoji_understanding <- as.factor(data$emoji_understanding)

levels(data$emoji_understanding)

```

We translate *mittelm√§√üig* to *moderate*, *eher gut* to *rather good*, *gut* to *good*, and *sehr gut* to *very good*:

```{r recode-understanding}

data <- data |> 
    mutate(emoji_understanding = recode(emoji_understanding,
                                        "mittelm√§√üig" = "moderate",
                                        "eher gut" = "rather good",
                                        "gut" = "good",
                                        "sehr gut" = "very good"))

levels(data$emoji_understanding)

```

The levels are still in the wrong order. We need to rearrange them in an ascending order from *moderate* to *very good*. To do this, we define a vector `c("moderate", "rather good", "good", "very good")`. Using the `factor()` function, we encode this vector as a factor:

```{r reorder-understanding}

data <- data |> 
    mutate(emoji_understanding = factor(emoji_understanding,
                                        levels = c("moderate",
                                                   "rather good",
                                                   "good",
                                                   "very good")))

levels(data$emoji_understanding)

```

The levels now look correct, so we can determine the frequencies for the different gender groups within `emoji_understanding`. We could do this by simply cross-tabulating gender with emoji understanding (see <https://elenlefoll.github.io/RstatsTextbook/8_DescriptiveStats.html> **8.1.3 Mode**). But since we know that the sizes of the gender subsets are very unequal, we also want to calculate the relative frequencies to make the numbers comparable. There is an easy way to calculate relative frequencies using the `proportions()` function (see <https://elenlefoll.github.io/RstatsTextbook/8_DescriptiveStats.html> **8.2.1 Distributions of categorical variables**). However, we need to make two additional considerations:

1.  Our aim is to calculate proportions within groups and not across the whole data.
2.  We want to create a comprehensive visualisation that contains both groups of men and women in a single barplot.

To achieve both, we have to first group our data, using the powerful combination of `group_by()` and `count()`. We create a new data frame `gender_understanding_count` and again keep only each participant's unique `submission_id` as above. We group the data by gender and count the frequencies for the different genders within the `emoji_understanding` factor:

```{r gender-understanding-freq}

gender_understanding_count <- data |>
  distinct(submission_id, .keep_all = TRUE) |>
  group_by(gender) |> 
  count(gender, emoji_understanding)

```

If we check our data frame `gender_understanding_count` with `View()`, it looks like this:

![The gender_understanding_count object as visualised using the View() function in RStudio](images/gender_understanding_count.png){#fig-gender_understanding_count fig-align="center" width="400"}

`n` is calculated by the `count()` function and represents the number of occurrences for each combination of `gender` and `emoji_understanding`. Next, we add a column with the relative frequencies, which we calculate with the formula `proportions(n) * 100`:

```{r gender-understanding-percent}

gender_understanding_count <- data |>
  distinct(submission_id, .keep_all = TRUE) |>
  group_by(gender) |> 
  count(gender, emoji_understanding) |> 
  mutate(percentage = proportions(n) * 100)

```

Finally, we print our frequency table:

```{r print-gender-understanding}

print(gender_understanding_count)

```

From the frequency table, we can already see that non-binary participants reported either a *rather good* or *good* understanding of emojis. A higher percentage of women (44.7%) reported a *very good* emoji understanding compared to men (38.5%). But let's create our barplot to see the distribution more clearly.

### Data visualisation {#sec-gender-understanding-vis}

As mentioned above, we filter out the very small group of non-binary participants for our visualisation:

```{r filter-gender}

gender_understanding_count <- gender_understanding_count |> 
  filter(gender != "non-binary")

```

We use `ggplot()` to create a barplot with `emoji_understanding` on the x-axis and the relative frequencies on the y-axis. The bars are coloured according to `gender`:

```{r gender-understanding-plot}

ggplot(gender_understanding_count, aes(x = emoji_understanding, 
                                       y = percentage, 
                                       fill = gender)) +
  geom_bar(stat = "identity", position = "dodge")

```

To make our plot more meaningful, we add a title and labels. We also change the colours manually to make it look nicer. The hexadecimal color values chosen here are from the colour-blind friendly palette "Set2" from the package [{RColorBrewer}](https://cran.r-project.org/web/packages/RColorBrewer/index.html) [@neuwirth2022package]. Since we only need two colours, we can easily insert them manually without having to install an additional package.

```{r gender-understanding-labs}

ggplot(gender_understanding_count, aes(x = emoji_understanding, 
                                       y = percentage, 
                                       fill = gender)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Self-reported Emoji Understanding by Gender",
       x = "Emoji understanding",
       y = "Percent") +
  scale_fill_manual(values = c("#bc5090", "#009E73"))

```

As you can see from the barplot, the gender distribution for emoji understanding is not as clear as for emoji use and emoji attitude.

::: callout-tip
#### Quiz time! {.unnumbered}

[**Q3.**]{style="color:green;"} How do you interpret this plot?

```{r echo=FALSE, results="asis"}

check_question(c("Proportionally more women than men reported a very good emoji understanding.", "Men are more evenly distributed across the levels of emoji understanding.", "Proportionally more women than men reported a moderate emoji understanding.", "The bars for both genders are highest in the good to very good range."), options = c("Proportionally more women than men reported a very good emoji understanding.", "Proportionally more women than men reported a moderate emoji understanding.", "Men are more evenly distributed across the levels of emoji understanding.", "Women are more evenly distributed across the levels of emoji understanding.", "Women reported a lower level of emoji understanding than men.", "The bars for both genders are highest in the good to very good range."), type = "checkbox",
random_answer_order = TRUE,
button_label = "Check answer",
right = "That's right! While proportionally more women than men reported a very good emoji understanding, a relatively large number of men also stated that they understood emojis very well. The bars for both genders are highest in the good to very good range. There are also more women than men in the moderate and rather good category. Generally, men are more evenly distributed across the levels of emoji understanding.",
wrong = "Not quite. Try again.")
check_hint("Four of the above options are correct interpretations of the plot.", hint_title = "üê≠ Click on the mouse for a hint.")

```

<br>
:::

Interestingly, compared to @fig-barplots, women were more confident in reporting that they used emojis frequently and had a positive attitude towards emojis than they were in reporting that they understood emojis well. It is possible that some women were more modest in rating their understanding of emojis, which could indicate a gender confidence gap. Reporting a good understanding likely requires more confidence compared to frequent use or positive attitudes.

## Comparing matching rates between AU conditions {#sec-au-plot}

We will now turn to exploring the central research question of @fricke2024semantic. Remember, it was: **Do AU differences lead to differences in meaning between the two emojis of a pair?** As mentioned in @sec-deconstructing, AUs are numbers which correspond to human-like facial features. In emoji pairs of the AU+ condition, the visual difference between the emojis is reflected in a number difference, e.g. *grinning face with big eyes* üòÉ (AU: **5** + 12 + 25 + 26) and *grinning squinting face* üòÜ (AU: 12 + 25 + 26 + **43**). In the AU- condition, the visual difference does not correspond to an AU difference, e.g. *grinning face with smiling eyes* üòÑ and *beaming face with smiling eyes* üòÅ (AU for both: 12 + 25 + 26 + 63).

Step by step, we will build an informative plot which will include all the information needed to answer this question. This plot will display how many times each emoji was chosen in its presumed corresponding context.

Ideally, we would plot matching rates based on a variable that tells us exactly when the participants responded with the matching emoji. Unfortunately, @fricke2024semantic's raw data do not include such a variable. We will tackle this by ourselves in this section.

### Preprocessing the data {#sec-au-data-preparation}

First, we need a variable that includes the experimental conditions of each trial. The experimental conditions tell us whether the visual difference between the presented emojis corresponded to an AU difference (AU+) or not (AU-), or whether a filler was presented.

We add a variable `AU_difference` that will include the necessary information. We do this by using a combination of `mutate`, `case_when` and `str_detect`:

```{r AU-variable}

data <- data |>
  mutate(AU_difference = case_when(str_detect(name, "AU") ~ "AU+", 
                                   .default = NULL))

```

The function `mutate` adds the column representing our variable. `str_detect` looks for a specific string in the column we specify. In our case, the column is called `name`, and the first string we need is `"AU"`.

The above code command means: look for the string `"AU"` in the column `name`, and in all cases where you find it (`case_when`), add the string `"AU+"` to a new column called `AU_difference`. We do this for the other conditions as well:

```{r AU-variable-complete}

data <- data |> 
  mutate(AU_difference = case_when(str_detect(name, "AU") ~ "AU+",
                                   str_detect(name, "N") ~ "AU-",
                                   str_detect(name, "filler") ~ "filler",
                                   .default = NULL))

```

A table checks that everything worked:

```{r table-AU}

table(data$AU_difference)

```

This looks promising. Since we are only interested in the experimental items, we now filter out filler trials:

```{r filter-filler}

data <- data |>
  filter(AU_difference != "filler")

```

We will now create another variable called `context`. The column of this variable will contain the contexts used in @fig-emojipairs. Again, we combine `mutate`, `case_when` and `str_detect`: In the column `question`, we look for context-characteristic strings, and add the context descriptions in case of a match. We check the output with `table()`.

```{r context-variable}

data <- data |> 
  mutate(context = case_when(str_detect(question, "freut sich") ~ "happiness",
                             str_detect(question, "lacht") ~ "(cheeky) laughter",

                             str_detect(question, "macht sich Sorgen") ~ "concern",
                             str_detect(question, "ist √ºberrascht") ~ "surprise",
                             str_detect(question, "ist etwas genervt") ~ "mild irritation",
                             str_detect(question, "√§rgert sich") ~ "annoyance",
                             str_detect(question, "am√ºsiert sich") ~ "amusement",
                             str_detect(question, "ist √ºbergl√ºcklich") ~ "(intense) happiness",
                             str_detect(question, "ist entt√§uscht") ~ "mild disappointment",
                             str_detect(question, "ist entt√§uscht") ~ "moderate disappointment",
                             str_detect(question, "ist gut gelaunt") ~ "happiness2",
                             str_detect(question, "ist verlegen") ~ "bashfulness",
                                   .default = NULL))


table(data$context)

```

::: callout-tip
#### Quiz time! {.unnumbered}

[**Q4.**]{style="color:green;"} Which problems become apparent when checking the output via the table?

```{r echo=FALSE, results="asis"}

check_question(c("All contexts have 159 occurences, except for mild disappointment which appears to exist 318 times.", "There are less contexts in the output than we have put in."), options = c("All contexts have 159 occurences, except for mild disappointment which appears to exist 318 times.", "There are less contexts in the output than we have put in.", "The context descriptions were not correctly assigned in case of matching strings.", "There are too many occurences of matches per context than can be reasonably assumed.", "There are more contexts in the output than we have put in."), type = "checkbox", 
random_answer_order = TRUE,
button_label = "Check answer",
right = "That¬¥s right! Something must have gone wrong. As you can see, it is always a good idea to check the output for inconsistencies.",
wrong = "Not quite, try again.")

```
:::

The contexts *mild disappointment* and *moderate disappointment* have created some issues: Both are described by *ist entt√§uscht* 'is disappointed'. Except for their coding in the column `name`, their data appears to be identical. At this point, we have no choice but to look for additional disambiguating information in @fricke2024semantic's analysis script: The emoji üôÅ (*mild disappointment*) is coded as `N-36-L1` and ‚òπÔ∏è (*moderate disappointment*) as `N-37-L1`. Using this information, we redefine the two contexts:

```{r recode-disappointment}

data <- data |> 
  mutate(context = case_when(
                             str_detect(name, "N-36") ~ "mild disappointment",
                             str_detect(name, "N-37") ~ "moderate disappointment",
                                   .default = context))

table(data$context)

```

Finally, we add the critical variable that describes whether there is a match between the chosen emojis and the contexts: if the emoji and the context agree, the variable will have the value *match*. Otherwise, the value will be *no match*.

```{r match-variable}

data <- data |> 
  mutate(
  match = case_when(
    context == "happiness" & response == "grinning_face_with_big_eyes" ~ "match",
    context == "(cheeky) laughter" & response == "grinning_squinting_face" ~ "match",
    context == "concern" & response == "hushed_face" ~ "match",
    context == "surprise" & response == "astonished_face" ~ "match",
    context == "mild irritation" & response == "neutral_face" ~ "match",
    context == "annoyance" & response == "expressionless_face" ~ "match",
    context == "amusement" & response == "grinning_face_with_smiling_eyes" ~ "match",
    context == "(intense) happiness" & response == "beaming_face_with_smiling_eyes" ~ "match",
    context == "mild disappointment" & response == "slightly_frowning_face" ~ "match",
    context == "moderate disappointment" & response == "frowning_face" ~ "match",
    context == "happiness2" & response == "smiling_face_with_smiling_eyes" ~ "match",
    context == "bashfulness" & response == "smiling_face" ~ "match",
    .default = "no match"))

```

### Building the plot(s) {#sec-au-plot-building}

We will now build our plots to visualise the matching rates per emoji pair. In a new dataframe called `data_AU`, we group the data by contexts. The command `count(match)` counts matches and non-matches for each context and stores them in the column `n`. We add the column `percent` which stores the rounded percentage of matches and non-matches for each context-pair:

```{r data-AU-context-match}

data_AU <- data |> 
  group_by(context) |> 
  count(match) |>
  mutate(percent = round(proportions(n)*100, 2))

```

Using the `View()` function, we take a look at our data:

![The first 14 columns of the dataframe data_AU as visualised using the View() function in RStudio](images/context_percentages.png){#fig-data-percentages fig-align="center" width="400"}

We plot the first emoji pair of the AU+ condition üòØ üò≤ with their respective contexts *concern* and *surprise*:

```{r create-plot-concern-surprise}
#| code-line-numbers: true

plot_concern_surprise <- data_AU |> 
filter(context == "concern" | context == "surprise") |>
ggplot(aes(x = context, y = percent, fill = match)) +
geom_col() +
scale_x_discrete(limits = c("concern", "surprise")) +
scale_fill_manual(values = c("#66C2A5", "#FC8D62")) +
geom_text(aes(label = percent), position = position_stack(vjust = 0.5)) +
labs (x= "context", y = "percent", title = "üòØ üò≤") +
theme_bw() +
theme(plot.title = element_text(hjust = 0.5), legend.title=element_blank())

```

The above command creates a barplot and stores it in `plot_concern_surprise`. These are the steps:

1.  Begin by assigning a clear name for the plot and call the data.
2.  Filter the contexts, such that only rows of the contexts *concern* or (`|`) *surprise* are taken into account.
3.  Create a `ggplot` with context values on the x-axis and percentages scaled on the y-axis. Fill the area inside geoms with colour according to match values.
4.  Display the plot as a barplot. By default, `geom_bar` counts how many times *match* and *no match* occur. However, as we have already calculated and stored the values in the column `percent`, we use `geom_col` to use the data as is.
5.  The context values, which are displayed on the x-axis, are discrete. With this command, we set and order the contexts.
6.  Adjust colours with values from "Set2" from the {RColorBrewer} package (see @sec-gender-understanding-vis).
7.  Annotate the percentages of matching rates by adding them as text and placing them inside the plot, in the middle of the according bar.
8.  Add labels: *context* on the x-axis, *percent* on the y-axis, and the corresponding emojis as the title.
9.  Add a theme, in this case `theme_bw()`.
10.  Plots are left-aligned by default. Since we want the emojis to be displayed on top of their corresponding context bars, we move the title to the center of the plot. We also remove the title of the legend because the *match* and *no match* values are self-explanatory.

Let's take a look at our plot:

```{r show-plot-concern-surprise}

plot_concern_surprise

```

We need not only one plot, but six: one for each emoji pair. We could write it all out for each emoji pair, but since the code is identical (except for the contexts and the emojis), it is way more efficient to define a function.

::: {.callout-note title="What are functions and how to define them?"}
So far, we have only used built-in R functions, but have not defined our own functions. Functions are reusable code snippets that perform specific tasks. You have already learned about built-in R functions in <https://elenlefoll.github.io/RstatsTextbook/7_VariablesFunctions.html> **7.4 Using built-in R functions**. However, for highly specific queries that are applied several times it makes sense to define a function. As a rule of thumb, whenever code seems redundant (you may find yourself copying and pasting a lot), it is best to define a function for that task.

The basic structure of a function is `function(argument)`. Looks familiar? Accordingly, we define a function the following way: `function(parameters){function body}`

These are the steps:

1.  We define a function using the keyword `function`. After this keyword, we write a list of **parameters** in parentheses. **Parameters** act as placeholders for the function's arguments.
2.  We then construct the **function body** and enclose it in curly brackets. The **function body** tells the function what it is meant to do when called upon.
3.  We also need to think of a name for our function under which we will be able to call it. The function is assigned to the name by `<-`.
:::

In our case, the process of defining a function is straightforward:

1.  We start with the keyword `function` and state that our function should take `contexts` as its first argument and `emojis` as its second argument, as only these change with each plot.
2.  We then simply paste the code we just wrote for our plot inside the curly braces, replacing the specific contexts and emojis with parameters.
3.  Our function is called `plot_AU_matches` because that is what it does: plotting AU matches.

```{r define-function}

plot_AU_matches <- function(contexts, emojis) {
  data_AU |> 
    filter(context %in% contexts) |> 
    ggplot(aes(x = context, y = percent, fill = match)) +
    geom_col() +
    scale_x_discrete(limits = contexts) +
    scale_fill_manual(values = c("#66C2A5", "#FC8D62")) +
    geom_text(aes(label = percent), position = position_stack(vjust = 0.5)) +
    labs (x= "context", y = "percent", title = emojis) +
    theme_bw() +
    theme(plot.title = element_text(hjust = 0.5), legend.title=element_blank())
}
```

We apply this function to all contexts and emoji pairs by filling them in as the arguments:

```{r apply-function}

plot_concern_surprise <- plot_AU_matches(c("concern", "surprise"), "üòØ üò≤")
plot_happiness_cheeky <- plot_AU_matches(c("happiness", "(cheeky) laughter"), "üòÉ üòÜ")
plot_mild_irr_annoyance <- plot_AU_matches(c("mild irritation", "annoyance"), "üòê üòë")
plot_mild_disapp_mod_dissap <- plot_AU_matches(c("mild disappointment", "moderate disappointment"), "üôÅÔ∏è ‚òπÔ∏è")
plot_amusement_int_happiness <- plot_AU_matches(c("amusement", "(intense) happiness"), "üòÑ üòÅ")
plot_happiness2_bashfulness <- plot_AU_matches(c("happiness2", "bashfulness"), "üòä ‚ò∫Ô∏è")
```

::: {.callout-note title="Inserting emojis in R" collapse="true"}
There are various ways to insert emojis in R. The easiest is to use the emoji keyboard (see @fig-emoji-keyboard). To open it on MacOS, use the keyboard shortcut `Crtl + Cmd + Space` or `fn + e` and on Windows `Windows logo key + . (period)`. The emoji keyboard is also available in RStudio, if you go to the "Edit" drop-down menu and click on "Emojis & Symbols". Alternatively, there are emoji libraries for R, for example {emo(ji)} developed by @wickham2024emoji.

As we want to display emojis within plots, we need to pay even more attention to graphics. Emojis as part of plots created by `ggplot` cannot be displayed just like that. Additional problems can occur when rendering a Quarto or R Markdown document to HTML.

If displaying emojis as part of plots in RStudio does not work for you, you will need to use the high-quality graphics library "AGG" ("Anti-Grain Geometry") or "Cairo" as a backend in RStudio. To do this, head to the "Tools" drop-down menu and click on "Global Options". Then, go to the "Graphics" tab and select the "AGG" or "Cairo" option (see @fig-agg).

::: {#fig-emoji-tools layout-ncol="2"}
![The emoji keyboard](images/emoji_keyboard.png){#fig-emoji-keyboard fig-align="center" width="270"}

![Recommended graphics backend in RStudio](images/AGG.png){#fig-agg fig-align="center" width="300"}

Tools for inserting and displaying emojis in RStudio
:::

To correctly render your Quarto document to HTML, you can use the [{ragg}](https://ragg.r-lib.org) package developed by @pedersen2024ragg. This package provides graphic devices based on AGG and includes advanced text rendering, with support for emojis. {ragg} can be used with knitr by using the following setup at the beginning of your document:

```{r setup-example}

knitr::opts_chunk$set(dev = "ragg_png")

```
:::

### Assembling with {patchwork} {#sec-au-patchwork}

By applying our self-defined function `plot_AU_matches` to all emoji pairs and contexts, we have created one barplot for each emoji pair. We will use the [{patchwork}](https://patchwork.data-imaginist.com) package [@pedersen2024patchwork] to assemble the plots, thereby creating an overview. As the name suggests, {patchwork} enables us to patch several plots together and arrange them nicely, so that the finished plot will be cohesive and informative.

![Patchwork artwork by Allison Horst, <https://allisonhorst.com/r-packages-functions>](images/patchwork.png){#fig-patchwork width="600"}

In line with the research question of @fricke2024semantic, we want to compare the matching rates of emojis and contexts in the AU+ condition with the matching rates in the AU- condition. Our goal is to create a plot that looks similar to this one by @fricke2024semantic:

![Plot of individual emoji pairs that compares AU conditions [@fricke2024semantic, p.11]](images/Fricke_AUplot.png){#fig-AUFricke width="700"}

First, let us plan the layout of our final plot with some placeholder names for the patchworks (`p1`, `p2`, and `p_combined`). In {patchwork}, plots are combined by `|` (horizontally), `/` (vertically), or `+` (generally).

```         
column1 <- p1 / p2 / p3

column2 <- p4 / p5 / p6

columns_combined <- column1 | column2
```

The final plot will have two columns and three rows: In both `p1` and `p2`, three plots are stacked on top of each other. These will be the plots of the AU+ and the AU- condition. We then put these patchworks next to each other for comparison (`p_combined`).

Now, we fill in the names of the plots and choose some meaningful names. To run the code, you will need to have the patchwork package installed `install.packages(patchwork)` and the library loaded `library(patchwork)`.

```{r AU-patch-condition}

#AU+ condition:
AU_plus_patch <-
  plot_concern_surprise / plot_happiness_cheeky / plot_mild_irr_annoyance

#AU- condition:
AU_minus_patch <-
  plot_mild_disapp_mod_dissap / plot_amusement_int_happiness / plot_happiness2_bashfulness

```

Since `AU_plus_patch` and `AU_minus_patch` are to be combined in one plot, we need to add titles to keep them apart. Technically, it is possible (and recommended!) to use the `plot_annotation` function of the {patchwork} package for this. However, annotations of this function are only shown at the highest nesting level. As we will be building a double-nested plot, any annotations we do on the "blocks-of-three"-level will not be displayed. We can work around this by using the function `wrap_elements`. This fixates the blocks in their current state and allows us to add titles in the form of `ggtitles` which relate the blocks to the conditions.

```{r patch-titles}

AU_plus_patch <- wrap_elements(plot = AU_plus_patch) +
  ggtitle("[AU+] condition")

AU_minus_patch <- wrap_elements(plot = AU_minus_patch) +
  ggtitle("[AU-] condition")

```

Finally, we put both elements together to get our final plot.

```{r AU-combined-patch}

AU_combined_patch <- AU_plus_patch | AU_minus_patch

```

```{r show-AU-combined-patch}
#| label: fig-AUpatch
#| fig-cap: "Plot that combines all subplots into one picture"

AU_combined_patch
```

It does not look exactly the same as the plot by @fricke2024semantic (see @fig-AUFricke) but it contains the same information. Which look do you prefer?

### Interpreting the plot

By looking and interpreting @fig-AUpatch, we can now finally answer the research question: Do AU differences lead to differences in meaning between the two emojis of a pair?

The answer is no, seemingly not. AU difference does not seem to be critical to the decision for an emoji in a context. As @fig-AUpatch shows, the matching emoji was "generally preferred with matching rates above chance level" [@fricke2024semantic, p. 11], both in the AU+ and in the AU- condition. Now, was all our work for nothing?

No, not at all! We can still draw some interesting inferences from the plot we created. For example, we see that minor visual differences between emojis do affect the understanding and selection of emojis in different contexts: By slightly varying the contexts, participants were made to choose emojis with different facial features. Notably, matching rates were quite similar within emoji pairs. In particular, this was the case for the contexts *happiness* üòÉ - *(cheeky) laughter* üòÜ and *happiness2* üòä - *bashfulness* ‚ò∫Ô∏è : they had less than a 2% difference between matching rates.

Through the following quiz questions, you can further interpret @fig-AUpatch. The correct answers will reveal how the information displayed can be made sense of.

::: callout-tip
#### Quiz time! {.unnumbered}

[**Q5.**]{style="color:green;"} In which context-pair did participants choose the matching emojis most often?

```{r echo=FALSE, results="asis"}

check_question("happiness and (cheeky) laughter", options = c("happiness and (cheeky) laughter", "concern and surprise", "amusement and (intense) happiness", "mild irritation and annoyance", "mild disappointment and moderate disappointment", "happiness2 and bashfulness "), type = "radio", 
random_answer_order = TRUE,
button_label = "Check answer",
right = "That's right! The great majority of participants (86.79% and 88.68%) decided for the matching emoji in the contexts *happiness* (üòÉ) and *(cheeky) laughter* (üòÜ).",
wrong = "Not quite, try again.")

```

<br><br> [**Q6.**]{style="color:green;"} How can a small difference (such as \< 2%) between matching rates within pairs be interpreted?

```{r echo=FALSE, results="asis"}
check_question("Within these pairs, a very similar amount of participants chose the matching emoji.", options = c("Within these pairs, a very similar amount of participants chose the matching emoji.", "Within these pairs, participants struggled the most to decide for one emoji over the other.", "Within these pairs, the least amount of participants chose the matching emoji.", "Within these pairs, half of the participants preferred the one emoji and half of them preferred the other."), type = "radio", 
random_answer_order = TRUE,
button_label = "Check answer",
right = "That's right! Of course, this does not mean that the same participants preferred the matching emojis for both members of the pair.",
wrong = "This is not correct. Look at the subplot *happiness* üòÉ - *(cheeky) laughter* üòÜ and think about its meaning.")
check_hint("A small difference implies that the *match* / *no match* ratio is very similar across contexts. For example, this is the case in the subplot *happiness* üòÉ - *(cheeky) laughter* üòÜ.", hint_title = "üê≠ Click on the mouse for a hint.")
```

<br><br> [**Q7.**]{style="color:green;"} Looking at the final patchwork (@fig-AUpatch), which subplot stands out most from the rest?

```{r echo=FALSE, results="asis"}

check_question("lower left", options = c("upper left", "upper right", "middle left", "middle right", "lower left", "lower right"), type = "radio", 
random_answer_order = TRUE,
button_label = "Check answer",
right = "Correct! The emoji pair *mild irritation* üòê - *annoyance* üòë sets itself apart from the rest: There is a considerable difference between the matching rates. Perhaps counterintuitively, this means that most participants opted for the same emoji in both contexts.",
wrong = "Not quite. Which plot looks significantly different than the others?")

```

<br><br> [**Q8.**]{style="color:green;"} Which interpretations of the lower left subplot are correct? Select all that apply.

```{r echo=FALSE, results="asis"}
check_question(c("The emoji üòê was chosen significantly less for its matching context than all the other emojis.", "Only in the üòêüòë pair, the matching rate for one emoji is above chance and for the other below chance."), options = c("The emoji üòê was chosen significantly less for its matching context than all the other emojis.", "There is a major difference between the matching rates of the contexts annoyance and happiness.","Only in the üòêüòë pair, the matching rate for one emoji is above chance and for the other below chance.", "Since matching rates differ a lot in the üòêüòë plot, AU difference seems to affect participants' preference."), type = "checkbox", 
random_answer_order = TRUE,
button_label = "Check answer",
right = "That's right! Apparently, two thirds (66.67 %) of participants favoured the non matching emoji in the *mild irritation*-context: Instead of üòê, they chose üòë. One of the narratives in this context was 'a malfunctioning wifi router'. Which emoji would you choose in this context, üòê or üòë?" ,
wrong = "Not quite. Consider the implications of a low matching rate versus a high matching rate.", alignment = "vertical")
check_hint("Two statements are correct. Consider the implications of a low matching rate versus a high matching rate.", hint_title = "üê≠ Click on the mouse for a hint.")
```

<br><br> [**Q9.**]{style="color:green;"} Which of the following reasons are likely to have caused this variance? Select all that apply.

```{r echo=FALSE, results="asis"}

check_question(c("The stories of the mild irritation context were perceived as more annoying than the authors had anticipated.", "The stories created for mild irritation and annoyance triggered a similar reaction."), options = c("The stories of the mild irritation context were perceived as more annoying than the authors had anticipated.", "The stories created for mild irritation and annoyance triggered a similar reaction.", "Unlike what was anticipated, most participants used the emojis üòê and üòë in very different contexts.", "The participants did not realize there was a difference between üòê and üòë."), type = "checkbox",
random_answer_order = TRUE,
button_label = "Check answer",
right = "That's right! These are two possible explanations. However, as we have no way of tracking the participants' reasoning, we can only make some educated guesses.",
wrong = "Not quite. Consider what could have caused the differing matching rates.", alignment = "vertical")
check_hint("Two of these are plausible reasons for the observed result. The plot suggests that participants preferred the same emoji for the stories associated with *mild irritation* and *annoyance*.", hint_title = "üê≠ Click on the mouse for a hint.")

```

<br>
:::

Overall, @fig-AUpatch shows that there was indeed a preference for context-matching emojis. However, the findings do not support the pictorial approach adopted by @fricke2024semantic: Whether or not emoji features coincided with human facial features, did not (significantly) affect the participants' decision for one emoji or the other.

## Conclusion {#sec-conclusion}

You are now a pro in handling barplots! You can build, customise, arrange, and interpret them. Barplots are powerful for visualising categorical data, offering a straightforward way to compare frequencies and make patterns apparent. However, they do have their limitations. For instance, they are not ideal for displaying continuous data. Building and assembling plots can be quite fiddly and it can take some trial-and-error to make the plot look like what you have imagined. But there is a solution for (almost) anything and hopefully, the beautiful plot you create in the process will be worth the effort.

Our analysis revealed gender-specific differences in emoji understanding, potentially indicating a gender confidence gap between men and women. Both genders, however, reported understanding emojis well overall. Our visualisations have been adjusted for the gender imbalance in the data, demonstrating the importance of accounting for differences in sample sizes.

By combining multiple plots, we have created an informative picture that answers the experiment‚Äôs research question. The question whether Action Unit (AU) differences are critical for emoji preference was answered in the negative. However, we have made several other discoveries along the way, and have found that small changes of emojis‚Äô facial features do affect choice patterns.

Emojis, it turns out, contain lots of information, and there is a science behind them ü§ì. While measuring why we prefer certain emojis over other ones can be challenging, our analysis has provided insights into this fascinating area of study.

## Declaration of collaboration {#sec-collaboration .unnumbered}

We have written this term paper in close collaboration. To roughly summarise who did what:

Rose:

-   title

-   Parts of "Chapter overview"

-   In "Introducing the study":

    -   texts "Deconstructing emojis into Action Units" and "The experiment"
    
    -   editing

-   In chapter "Exploring the relationship between gender and emoji understanding":

    -   text on ggplot colours
    
    -   minor editing

-   Chapter "Comparing matching rates between AU conditions"

-   In "Conclusion"

    -   part on barplots
    
    -   part on research question & end

Gina:

-   Parts of "Chapter overview"

-   In "Introducing the study":

    -   editing

    -   quiz question

-   Chapter "Exploring the relationship between gender and emoji understanding"

-   In chapter "Comparing matching rates between AU conditions":

    -   data preprocessing code (code in chapter 3.1 up to half of defining the matches)

    -   function "plot_AU_matches"

    -   part "Inserting emojis in R"

    -   editing until chapter 3.3

-   In conclusion:

    -   part on gender-specific insights

    -   editing

Details be found in our Git repository: <https://github.com/ginareinhard/term_paper>

## References {#sec-references .unnumbered}
