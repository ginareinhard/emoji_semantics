---
title: "Term paper"
subtitle: ""
author: "Rose H√∂rsting & Gina Reinhard"
date: "2024-09-15"
engine: knitr
bibliography: references.bib
format: 
  html:
    df-print: default
    toc: true
    toc-depth: 3
    fig-width: 10
    fig-height: 8
    number-sections: true
    embed-resources: true
link-citations: true
csl: "apa_7th.csl"
number-sections: true
---
<style>
p {
  text-align: justify;
}
</style>

```{r ragg, include=FALSE}

#install.packages("ragg")
library(ragg)

```

```{r setup, include=FALSE}

knitr::opts_chunk$set(dev = "ragg_png", warning = FALSE, message = FALSE)

```

```{r checkdown, include=FALSE}

library(checkdown)

```

#### **Chapter overview** {#sec-chapter-overview .unnumbered}

This chapter will walk you through:
<!-- Vorschl√§ge -->

- how to overview/explore the data of a study 
- access the specific data you are interested in
- frequency analysis
- visualisations
- building a complex plot and interpreting it

We will work with data of the study by @fricke2024semantic.

## Session set up {#sec-session-set-up}

```{r load-libraries, message=FALSE}

library(here)
library(tidyverse)
#install.packages("ggpubr")
library(ggpubr)
#install.packages("scales")
library(scales)
#install.packages("patchwork")
library(patchwork)

```

```{r colour-palettes, include=FALSE}

# colourblind-friendly
# https://www.datanovia.com/en/blog/top-r-color-palettes-to-know-for-great-data-visualization/#r-base-color-palettes

cbp1 <- c("#999999", "#E69F00", "#56B4E9", "#009E73",
          "#F0E442", "#0072B2", "#D55E00", "#CC79A7")

# another option with an additional package:
#install.packages("RColorBrewer")
library(RColorBrewer)
display.brewer.all(colorblindFriendly = TRUE)
# second list of colours is best suited for nominal/categorical data: "Set2", "Paired", "Dark2"

# however, a palette may be too much as we only need two colours at the same time, but which ones? two for men/women and two different ones for match/no match?

```

## Introducing the study {#sec-introducing-the-study}

<!-- Kapitel √ºberarbeitet -->

<!--Everyday, millions of people use emojis in their text messages as a means to communicate their emotions. -->

Face emojis stand in for facial expressions and thereby fundamentally contribute to the subtext of a text message. Several studies have investigated the relationship between emojis and the emotions they depict. However, as emojis are a relatively recently occuring phenomenon, there is still a lot to be discovered. In this chapter, we will look into this study by @fricke2024semantic:

<!-- Ich finde die Einleitung f√ºr eine Hausarbeit sehr gut, mein erster Eindruck war nur ggf. f√ºr unseren Zweck zu weit ausgeholt? -->

> Fricke, L., Grosz, P. G., & Scheffler, T. (2024). Semantic differences in visually similar face emojis. Language and Cognition, 1‚Äì15. <https://doi.org/10.1017/langcog.2024.12>

### Deconstructing emojis into Action Units {#sec-deconstructing}

They compare visually similar emojis using a face emoji annotation system developed by @fugate2021implications. This annotation system is based on the Facial Action Coding System (FACS) for human faces invented by @ekman1978facial. @fricke2024semantic assign numbers to features such as *eyebrows arched* and *eyes wide*. These numbers are called Action Units, short AUs. As you can see in @fig-emojipairs, each emoji consists of several AUs:

![Emoji pairs and their contexts, @fricke2024semantic](images/emoji_pairs.png){#fig-emojipairs fig-align="center" width="700"}

@fricke2024semantic distinguish two different types of emoji pairs: In the \[AU+\] condition, the visual difference between emojis corresponds to a difference between AUs. In the \[AU-\] condition, the visual difference does not correspond to an AU difference.

Their central research question is: **Do AU-differences lead to differences in meaning between the two emojis of a pair?**

<!-- @fricke2024semantic compare two approaches that answer this question differently: The pictorial approach by @maier2023emojis considers emojis to be depictions of the writer¬¥s face in the moment of typing. In contrast, the lexicalist approach (@grosz2023semantics) emphasises the meanings of emojis as described by words.
Following the pictorial approach, -->
@fricke2024semantic predict in line with the pictorial approach by @maier2023emojis that visual differences between emojis that do not correspond to human facial features (AU-) are less semantically relevant than differences corresponding to human facial features (AU+).

<!-- Beispiele gel√∂scht -->

::: {.callout-note title="How did the experiment work?"}
### Design {#sec-design}

Three \[AU+\] and three \[AU-\] emoji pairs were created, as depicted in @fig-emojipairs. Each pair was assigned two contexts (for example *happiness* and *(cheeky) laughter*), where each context corresponded to a prominent usage or meaning of one emoji but not the other. The contexts were assigned based on <https://emojipedia.org> and on a previous norming study by the authors. As testing items, four one-sentence-stories were created for each of the contexts (= 48 items). These stories were then divided up into into four lists of 12 items. Each list also contained 12 filler items, so that each participant saw 24 items.

### Procedure {#sec-procedure}

As you can see in @fig-testitems, situations that illustrated the contexts were presented to participants, and participants were asked to help a male ("Alex") or female ("Anna") friend choosing the fitting emoji. Each participant saw each emoji pair twice. The rate with which the context-matching emoji was chosen was measured.

![Example of a test item in @fricke2024semantic¬¥s experiment](images/test_items.png){#fig-testitems fig-align="center" width="500"}

The lexicalist approach predicts that it does not matter whether visual (AU) differences correspond to facial characteristics or not: For both types of pairs, the context-matching emoji should be chosen more often than the non-matching one. <!-- erstmal hierhin verschoben, weil von den Kontexten vor der blauen Box noch nicht die Rede war -->

In contrast, @fricke2024semantic expect that participants will choose the context-matching emoji more often in the \[AU+\] condition than in the \[AU-\] condition. For the \[AU-\] pairs, the pattern is predicted to be more random. <!-- erstmal hierhin verschoben, weil von den Kontexten vorher noch nicht die Rede war -->
:::

## Importing the data {#sec-importing-the-data}

Import the data using "here":

```{r import-data, message=FALSE}

raw_data <- read.csv(file = here("data", "raw_data.csv"))

```

As specified by @fricke2024semantic (p. 8), we filter out participants who exceed the maximum age of 35 years. (refer to <https://elenlefoll.github.io/RstatsTextbook/7_VariablesFunctions.html> **7.5.2¬†Piped Functions**).

```{r filter-age}

data <- raw_data |> 
  filter(age <= 35)

```

## Exploring the relationship between gender and emoji understanding {#sec-gender-understanding}

@fricke2024semantic also asked participants about their gender, their attitude towards emojis, how often they use emojis on WhatsApp and how well they think they understand emojis. They visualised the distribution of male and female gender for emoji use and emoji attitude as barplots:

::: {#fig-barplots layout-ncol="2"}

![Barplot "Emoji use by gender"](images/emoji_use.png){#fig-emojiuse fig-align="center" width="550"}

![Barplot "Attitude towards emojis by gender"](images/emoji_attitude.png){#fig-emojiattitude fig-align="center" width="550"}

Barplots from @fricke2024semantic
:::

The plots in figure @fig-barplots show that women use emojis more often and have a more positive attitude towards emojis than men. We want to find out whether women also reported a higher level of emoji understanding than men. Our analysis will involve 3 steps:

1.) calculating the absolute frequencies of the genders in the data\
2.) calculating the relative frequencies of the different levels of emoji understanding for each gender\
3.) visualising the frequencies in a barplot similar to the plots above

<!-- descriptive statistics? -->

### Gender frequency analysis {#sec-gender-freq}

Let's first get a general overview: How many men, women, and non-binary people participated in the study?

The relevant variable in the data set is called `gender`. However, you will see that the names of the different gender groups are in German. Before we start analysing, we should translate them into English. To figure out what the the labels of the different genders are, we use the `levels()` function. `levels()` applies to factors, so we first need to convert `gender` with the function `as.factor()`:

```{r convert-gender}

data$gender <- as.factor(data$gender)

```

Now, we can look at what the levels of our factor `gender` are:

```{r gender-levels}

levels(data$gender)

```

Using a combination of `mutate()` and `recode()`, we translate *m√§nnlich* to *men*, *weiblich* to *women*, and *divers* to *non-binary*:

```{r recode-gender}

data <- data |> 
  mutate(gender = recode(gender, 
                         "m√§nnlich" = "men", 
                         "weiblich" = "women", 
                         "divers" = "non-binary"))

levels(data$gender)

```

Now that the genders have English names, we want to determine how many men, women, and non-binary subjects participated. This is not straightforward, because the data frame contains 24 rows for each subject, as each participant saw 24 items (see @sec-design). If we were to simply count the occurrences of *men*, *women*, and *non-binary* in the data, we would end up with 24 times the values of the frequencies.

To determine the actual gender distribution, we need to group the data according to the subjects' unique IDs. To do this, we apply the `group_by` function to the `submission_id` variable. We then pipe `count(gender)` to this to count the genders by `submission_id`:

```{r gender-freq}

gender_count <- data |> 
  group_by(submission_id) |> 
  count(gender)

```

The result is stored in a new data frame called `gender_count`. Now we can look at the distribution using the `table()` function:

```{r gender-table}

table(gender_count$gender)

```

Alternatively, we can use the `distinct()` function to keep only unique occurrences (exactly: the first unique occurrence) of each submission_id. The argument `.keep_all` is set to `TRUE`, which means that all other variables in the data frame are kept and not deleted:

```{r gender-distinct}

gender_count <- data |> 
  distinct(submission_id, .keep_all = TRUE)

table(gender_count$gender)

```

The gender distribution is very uneven: 109 men, 47 women, and 3 non-binary people participated in the study. This is likely to skew our visualisation. To solve this problem, we will, like @fricke2024semantic, use relative rather than absolute frequencies and exclude the very small group of three non-binary participants for our visualisation.

### How well do the different genders understand emojis? {#sec-gender-understanding-freq}

Next, we calculate the relative frequencies of the different levels of emoji understanding for each gender. Just like with `gender`, we have to do some data wrangling first. Again, we convert the variable `emoji_understanding` as a factor to get its levels:

```{r convert-understanding}

data$emoji_understanding <- as.factor(data$emoji_understanding)

levels(data$emoji_understanding)

```

We translate *mittelm√§√üig* to *moderate*, *eher gut* to *rather good*, *gut* to *good*, and *sehr gut* to *very good*:

```{r recode-understanding}

data <- data |> 
    mutate(emoji_understanding = recode(emoji_understanding,
                                        "mittelm√§√üig" = "moderate",
                                        "eher gut" = "rather good",
                                        "gut" = "good",
                                        "sehr gut" = "very good"))

levels(data$emoji_understanding)

```

The levels are still in the wrong order. We need to rearrange them in an ascending order from *moderate* to *very good*. To do this, we define a vector `c("moderate", "rather good", "good", "very good")`. Using the `factor()` function, we encode this vector as a factor:

```{r reorder-understanding}

data <- data |> 
    mutate(emoji_understanding = factor(emoji_understanding,
                                        levels = c("moderate",
                                                   "rather good",
                                                   "good",
                                                   "very good")))

levels(data$emoji_understanding)

```

The levels now look correct, so we can count the frequencies for the different gender groups within `emoji_understanding`. We create a new data frame `gender_understanding_count` and again keep only each participant's unique `submission_id` as above. We group the data by gender and count the frequencies for the different genders within the `emoji_understanding` factor:

```{r gender-understanding-freq}

gender_understanding_count <- data |>
  distinct(submission_id, .keep_all = TRUE) |> 
  group_by(gender) |> 
  count(gender, emoji_understanding)

```

If we check our data frame `gender_understanding_count` with `View()`, it looks like this:

![The gender_understanding_count object as visualised using the View() function in RStudio](images/gender_understanding_count.png){#fig-gender_understanding_count fig-align="center" width="400"}

Since the sizes of the gender groups are very unequal, we add a column with the relative frequencies to make the numbers comparable. We calculate the relative frequencies using the formula `percentage = (n/total) * 100`, where we define `total` as `sum(n)` (in other words: the sum of all absolute numbers within each gender group):

```{r gender-understanding-percent}

gender_understanding_count <- data |>
  distinct(submission_id, .keep_all = TRUE) |> 
  group_by(gender) |> 
  count(gender, emoji_understanding) |> 
  mutate(total = sum(n), 
         percentage = (n/total) * 100)

```

Finally, we print our frequency table:

```{r print-gender-understanding}

#gender_understanding_count <- gender_understanding_count |> 
#  select(gender, emoji_understanding, n, percentage)

print(gender_understanding_count)

```

<!-- interpret frequencies? -->

### Data visualisation {#sec-gender-understanding-vis}

As mentioned above, we filter out the very small group of non-binary participants for our visualisation:

```{r filter-gender}

gender_understanding_count <- gender_understanding_count |> 
  filter(gender != "non-binary")

```

We use `ggplot()` to create a barplot in which emoji understanding is arranged in ascending order on the x-axis and the relative frequencies on the y-axis. The bars are coloured according to gender:

```{r gender-understanding-plot}

ggplot(gender_understanding_count, aes(x = emoji_understanding, 
                                       y = percentage, 
                                       fill = gender)) +
  geom_bar(stat = "identity", position = "dodge")

```

To make our plot more meaningful, we add a title and labels. We also change the colours manually to make it look nicer:

```{r gender-understanding-labs}

ggplot(gender_understanding_count, aes(x = emoji_understanding, 
                                       y = percentage, 
                                       fill = gender)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Self-reported Emoji Understanding by Gender",
       x = "Emoji understanding",
       y = "Percent") +
  scale_fill_manual(values = c("#bc5090", "#009E73"))

```

As you can see from the barplot, the gender distribution for emoji understanding is not as clear as for emoji use and emoji attitude: while proportionally more women than men reported a *very good* emoji understanding, a relatively large number of men also stated that they understood emojis very well. There are also more women than men in the *moderate* category. The bars for both genders are highest in the *good* to *very good* range.

## Comparing matching rates between AU-conditions (or across emoji pairs) {#sec-au-plot}

We will now turn to exploring the central research question of @fricke2024semantic. Remember, it was: **Do AU-differences lead to differences in meaning between the two emojis of a pair?**

Step by step, we will build an informative plot which will include all the information needed to answer this question. This plot will display how many times each emoji was chosen in its presumed corresponding context.

Ideally, we would plot matching rates based on a column that tells us exactly when the participants responded with the matching emoji. Unfortunately, @fricke2024semantic¬¥s data does not include such a column (yet). We will tackle this by ourselves in the following section.

### Preparing the data {#sec-au-data-preparation}

First, we need a column that includes the experimental conditions of each trial. That is, was the visual difference between the presented emoji an AU-difference (AU+) or not (AU-)? Or was a pair of filler emojis presented?

We add a column `AU_difference` that will include all the necessary information by using a combination of `mutate` (which adds the column), `case_when` and `str_detect`.

The function `str_detect` looks for a specifc string in the column we specify. In our case, the column is called name, and the first string we need is "AU".

```{r}

#delete this code chunk?

data <- data |>
  mutate(AU_difference = case_when(str_detect(name, "AU") ~ "AU+", 
                                   .default = NULL))

```

With the code `str_detect(name, "AU") ~ "AU+"`, we say: look for the string "AU" in the column `name`, and in all cases where you find it (`case_when`), add the string "AU+" to the column `AU_difference`. We do this for the other conditions as well.

```{r}

data <- data |> 
  mutate(AU_difference = case_when(str_detect(name, "AU") ~ "AU+",
                                   str_detect(name, "N") ~ "AU-",
                                   str_detect(name, "filler") ~ "filler",
                                   .default = NULL))

```

A table checks that everything worked:

```{r}

table(data$AU_difference)

```

This looks promising. Since we are only interested in the experimental items, we now filter out filler trials:

```{r}

data <- data |>
  filter(AU_difference != "filler")

# alternative (if code chunk above is deleted): 
#data <- data |> 
#  filter(!str_detect(name, "filler"))

```

Now, we will create another column called `context` to which we will add the brief context descriptions used in @fig-emojipairs. However, we need to be careful: Both "mild disappointment" and "moderate disappointment" are described by *ist entt√§ucht* "is disappointed". We will deal with this in a second, but we will exclude these contexts for now.

```{r}

data <- data |> 
  mutate(context = case_when(str_detect(question, "freut sich") ~ "happiness",
                             str_detect(question, "lacht") ~ "(cheeky) laughter",

                             str_detect(question, "macht sich Sorgen") ~ "concern",
                             str_detect(question, "ist √ºberrascht") ~ "surprise",
                             str_detect(question, "ist etwas genervt") ~ "mild irritation",
                             str_detect(question, "√§rgert sich") ~ "annoyance",
                             str_detect(question, "am√ºsiert sich") ~ "amusement",
                             str_detect(question, "ist √ºbergl√ºcklich") ~ "(intense) happiness",
                             str_detect(question, "ist entt√§uscht") ~ "mild disappointment",
                             str_detect(question, "ist √ºbergl√ºcklich") ~ "(intense) happiness",
                             #str_detect(question, "ist entt√§uscht") ~ "mild disappointment",
                             #str_detect(question, "ist entt√§uscht") ~ "moderate disappointment",
                             str_detect(question, "ist gut gelaunt") ~ "happiness2", #called this "happiness2" for now
                             str_detect(question, "ist verlegen") ~ "bashfulness",
                                   .default = NULL))


table(data$context)

```

Again, we combine `mutate`, `case_when` and `str_detect`: In the column `question`, we look for a context-characteristic strings, and add the context descriptions in case of a match. We check the output with `table()`.

(A problem becomes apparent when checking the output: All contexts have 159 occurences, except for "mild disappointment" which appears to exist 318 times. Something must have gone wrong.)

Now for the problematic "mild disappointment" / "moderate disappointment" with their matching emojis üôÅ / ‚òπÔ∏è : Their data appears to be identical except for their coding in the column "name". The emoji üôÅ ("mild disappointment") is named `N-36-L1` and ‚òπÔ∏è ("moderate disappointment") is coded as `N-37-L1`. Using this, we define these contexts as well. <!--(citing original analysis script, meaning of N-36 = "mild disappointment", meaning of N-37 = "moderate disappointment")-->

```{r}

data <- data |> 
  mutate(context = case_when(
                             str_detect(name, "N-36") ~ "mild disappointment",
                             str_detect(name, "N-37") ~ "moderate disappointment",
                                   .default = context))

table(data$context)

```

Finally, we add the critical column that includes whether the chosen emojis and contexts match: If the response-emoji and the context agree, the column will have the value "match". Otherwise, the value will be "no match".

```{r}

data <- data |> 
  mutate(
  match = case_when(
    context == "happiness" & response == "grinning_face_with_big_eyes" ~ "match",
    context == "(cheeky) laughter" & response == "grinning_squinting_face" ~ "match",
    context == "concern" & response == "hushed_face" ~ "match",
    context == "surprise" & response == "astonished_face" ~ "match",
    context == "mild irritation" & response == "neutral_face" ~ "match",
    context == "annoyance" & response == "expressionless_face" ~ "match",
    context == "amusement" & response == "grinning_face_with_smiling_eyes" ~ "match",
    context == "(intense) happiness" & response == "beaming_face_with_smiling_eyes" ~ "match",
    context == "mild disappointment" & response == "slightly_frowning_face" ~ "match",
    context == "moderate disappointment" & response == "frowning_face" ~ "match",
    context == "happiness2" & response == "smiling_face_with_smiling_eyes" ~ "match",
    context == "bashfulness" & response == "smiling_face" ~ "match",
    .default = "no match"))

```

### Building the plot(s) {#sec-au-plot-building}

In a new dataframe `AU_plot`, we store all and only the columns needed to build our plot:

```{r AU difference , matching rates, context}

data_AU <- data |> 
  group_by(context) |> 
  count(match) |> #counts matches and non-matches (match((yes/no)) for each context
  mutate(percent = round(n/sum(n)*100, 2)) #creates a new column with the percentages for each of the above counts (in relation to the sum of all matches/non-matches within each context, rounded to 2 digits)

```

The data is grouped by contexts, matches and non-matches are counted for each context and stored in a column `n`, a column `percent` is added which stores the percentage of matches and non-matches for each context pair.

Let¬¥s plot the first emoji pair \[\AU+\] condition üòØ üò≤, with their respective contexts "concern" and "surprise."

```{r}

plot_concern_surprise <- data_AU |> 
filter(context == "concern" | context == "surprise") |> #1.
ggplot(aes(x = context, y = percent, fill = match)) + #2.
geom_col() + #3.
scale_x_discrete(limits = c("concern", "surprise")) + #4.
scale_fill_brewer(palette = "Set2") + #5.
geom_text(aes(label = percent), position = position_stack(vjust = 0.5)) + #6.
labs (x= "context", y = "percent", title = "üòØ üò≤") + #7.
theme_bw() + #8.
theme(plot.title = element_text(hjust = 0.5), legend.title=element_blank()) #9.

```

The above command creates a barplot and stores it in `plot_concern_surprise`. These are the steps:

1.  Filter out the contexts, so that only rows with either the context "concern" or (`|`) "surprise" are taken into account.
2.  Create a ggplot with context values on the x-axis and percent scaled on the y-axis. Fill the area inside geoms with colour according to match values.
3.  Display the plot as a barplot. By default, `geom_bar` counts how many times matches/ no matches occurred. However, as our data already includes the counts for each group (column `n`), we use `geom_col` to use the data as is.
4.  The "context" values, which are displayed on the x.axis, are discrete. With this command, we set and order the contexts.
5.  Adjust colours (manually or with the package `RColorBrewer`)
6.  Annotate the percentages of matching rates by adding them as text and placing them inside the plot, in the middle of the according bar.
7.  Add labels: "context" on the x-axis, "percent" on the y-axis, emojis as the title
8.  Add a theme.
9.  Plots are left-aligned by default. Since we want the emojis to be displayed on top of their matching context bars, we move the title to the center of the plot. We also remove the title of the legend since the match/no match values are self-explanatory.

Let¬¥s take a look at our plot.

```{r}

plot_concern_surprise

```

We need not only one plot, but six: One for each emoji pair. We could write it all out, but since the code is identical except for the contexts and the emojis, it is way more efficient to define a function.

::: {.callout-note title="What are functions and how to define them?"}
So far, we have only used functions, but not defined any functions ourselves...

<!-- eingef√ºgt, da Elen grundlegende Definition von Funktionen wollte -->
:::

In our case, the process of defining a function is straightforward: We state that the function should have take "contexts" as its first argument and "emojis" as its second argument. We then simply repeat the code we just wrote, only replacing the specific contexts and emojis with the general argument names.

```{r}

plot_AU_matches <- function(contexts, emojis) {
  data_AU |> 
    filter(context %in% contexts) |> 
    ggplot(aes(x = context, y = percent, fill = match)) +
    geom_col() +
    scale_x_discrete(limits = contexts) +
    scale_fill_brewer(palette = "Set2") +
    geom_text(aes(label = percent), position = position_stack(vjust = 0.5)) +
    labs (x= "context", y = "percent", title = emojis) +
    theme_bw() +
    theme(plot.title = element_text(hjust = 0.5), legend.title=element_blank())
}

```

We apply this function to all emoji pairs and contexts by filling in the argument names:

```{r}

plot_concern_surprise <- plot_AU_matches(c("concern", "surprise"), "üòØ üò≤")
plot_happiness_cheeky <- plot_AU_matches(c("happiness", "(cheeky) laughter"), "üòÉ üòÜ")
plot_mild_irr_annoyance <- plot_AU_matches(c("mild irritation", "annoyance"), "üòê üòë")
plot_mild_disapp_mod_dissap <- plot_AU_matches(c("mild disappointment", "moderate disappointment"), "üôÅÔ∏è ‚òπÔ∏è")
plot_amusement_int_happiness <- plot_AU_matches(c("amusement", "(intense) happiness"), "üòÑ üòÅ")
plot_happiness2_bashfulness <- plot_AU_matches(c("happiness2", "bashfulness"), "üòä ‚ò∫Ô∏è")

```

::: {.callout-note title="Inserting emojis in R"}
<!-- (move this chapter/subchapter?) -->

There are various routes to displaying emojis in R.

The easiest way is to use the emoji keyboard (on Mac with the Shortcut fn+e). The emoji keyboard is also available in RStudio (Edit -\> Emojis & Symbols). Alternatively, there are emoji libraries, for example "emo(ji)" (<https://github.com/hadley/emo>).

As we want to display emojis within plots using ggplot: We have to use AGG/Cairo? as Backend in R Studio (Tools -\> Global Options -\> Graphics -\> Backend -\> AGG) \[explain AGG/Cairo\]. (Only necessary for Mac?)

For rendering the output from .qmd (or Markdown?) to HTML (or pdf?) we can either:

-   save the plots with ggsave() and insert them

or

-   use the ragg library (<https://ragg.r-lib.org>) ("ragg can be used as the graphic back-end to the RStudio device (for RStudio \>= 1.4) by choosing¬†*AGG*¬†as the backend in the graphics pane in general options (see screenshot)")

:::

### Assembling with patchwork {#sec-au-patchwork}

By applying our self-defined function `plot_AU_matches` to all emoji pairs and contexts, we have created one barplot for each emoji pair. We will use the `patchwork` package [@pedersen2024patchwork] to assemble the plots in an overview. As the name suggests, the `patchwork` package enables us to patch several plots together and arrange them nicely, so that the finished graph will be cohesive and informative.

![Patchwork artwork by Allison Horst, <https://allisonhorst.com/r-packages-functions>](images/patchwork.png){#fig-patchwork width="600"}

In line with the research question of @fricke2024semantic, we want to compare the matching rates of emojis and contexts in the \[AU+\] condition with the matching rates in the \[AU-\] condition. In the `patchwork` package, plots are combined by `|` (horizontally), `/` (vertically), or `+` (generally).

First, let us plan the layout of our final graph with some placeholder names:

```         
p1 <- x / y / z

p2 <- a / b / c

p_combined <- p1 | p2
```

In each of the patchworks `p1` and `p2`, three plots are stacked on top of each other. These will be the plots of the \[AU+\] condition and the \[AU-\] condition. We will then put these patchworks next to each other for comparison (`p_combined`). The final graph will have two columns and three rows.

Now, we simply need to fill in the names of the plots and choose some meaningful names:

```{r}

#[AU+] condition:
AU_plus_patch <- 
  plot_concern_surprise / plot_happiness_cheeky / plot_mild_irr_annoyance

#[AU-] condition:
AU_minus_patch <- 
  plot_mild_disapp_mod_dissap / plot_amusement_int_happiness / plot_happiness2_bashfulness

```

The `plot_layout` function takes the argument `guides`. By setting this argument to `"collect"`, identical legends of all plots within the patchwork are merged.

```{r}

#AU+ condition:
AU_plus_patch <- AU_plus_patch +
  plot_layout(guides = "collect")

#AU- condition:
AU_minus_patch <- AU_minus_patch +
  plot_layout(guides = "collect")

```

Since `AU_plus_patch` and `AU_minus_patch` are to be combined in one graph, we need to add titles to them to keep them apart. Technically, it is possible (and recommended!) to use the `plot_annotation` function of the `patchwork` package for this. However, annotations of this function are only shown at the highest nesting level. As we will be building a double-nested plot, any annotations we do on the "blocks-of-three"-level will not be displayed. We can work around this by using the function `wrap_elements`. This fixates the blocks in their current state and allows us to add titles in the form of `ggtitles` which relate the blocks to the conditions. Unfortunately, there is one small downside to this approach, as we will see in a second.

```{r}

AU_plus_patch <- wrap_elements(plot = AU_plus_patch) +
  ggtitle("[AU+] condition")

AU_minus_patch <- wrap_elements(plot = AU_minus_patch) +
  ggtitle("[AU-] condition")

```

Finally, we put both elements together to get our final graph.

```{r}

AU_combined_patch <- AU_plus_patch | AU_minus_patch

AU_combined_patch

```

```{r image AU plot, include=FALSE}

ggsave(filename = "images/AU_plot.png", width = 3400, height = 2000, units = "px")

```

This graph contains information on the matching rates of all emoji pairs with their contexts. However, you will probably notice that the graph contains two identical legends. This is not ideal but it is the trade-off we take by using the `wrap_elements` function: We have fixated the patchworks in their state with their legends, therefore the legends cannot be merged later. 

There are a couple of other options that will produce other outcomes, however, none is going to be perfect. They are to delete the legends from both blocks, keep the legend of one block and delete the other (this makes the bars take up the space of the legend, i.e. the bars in one block become wider than in the other one), or keep the legends of all six plots. 

We have opted to create one legend for each condition, but feel free to try the other options for yourself and see how it affects the final product. <!-- possible task? -->

::: callout-tip
#### Quiz time! {.unnumbered}

[**Q1.**]{style="color:green;"} Looking at the final patchwork, which "sub-plot" shows the most significant finding?

```{r echo=FALSE, results="asis"}

check_question("lower left", options = c("upper left", "upper right", "middle left", "middle right", "lower left", "lower right"), type = "radio", 
random_answer_order = TRUE,
button_label = "Check answer", q_id = 5,
right = "That¬¥s right! There is a notable difference between the matching rates.",
wrong = "Not quite, try again.")

```


[**Q2.**]{style="color:green;"} Which interpretation of this finding is most accurate?

```{r echo=FALSE, results="asis"}
check_question("üòê was chosen significantly less for its matching context than all the other emojis.", options = c("üòê was chosen significantly less for its matching context than all the other emojis.", "There is a major difference between matching rates of the contexts happiness2 and bashfulness.","Noch was drittes"), type = "radio", 
random_answer_order = TRUE,
button_label = "Check answer", q_id = 1,
right = "That¬¥s right!",
wrong = "Not quite, try again.")
```
:::

As you have now experienced, building plots and assembling them can be quite fiddly. You may get lost in details and may need to accept some trade-offs. It can take some time and a lot of trial-and-error to make the final plot look like what you have imagined. However, there is a solution for (almost) anything and hopefully, the beautiful graph you create in the process will make up for the trouble.

### Interpreting the plot
"For almost all contexts, the matching emoji is generally preferred with matching rates above chance level. In the case of the pair neutral face and expressionless face (   and   ), however, the latter emoji was preferred both in the ‚Äòannoyance‚Äô and in the ‚Äòmild irritation‚Äô context." [@fricke2024semantic].

Do AU-differences lead to differences in meaning between the two emojis of a pair?

"each emoji is preferred over a visually similar emoji in a context that represents a prominent aspect of its meaning, as determined on the basis of the emoji‚Äôs Emoji- pedia.org entry and a norming experiment. Thus, subtle differences in emojis that otherwise look alike lead to differences in meaning."

exception is the pair mild disappointment - moderate disappointment

"Our experiment indicates that the small visual difference between the two emojis of a pair does, in fact, create a difference in meaning. This is equally the case for [AU +] differences that map to different facial actions in human faces and for [AU-] differences that represent the same facial actions in a human face."

main finding: "context-matching emojis are chosen significantly above chance level in all conditions."

## Conclusion {#sec-conclusion}

## References {#sec-references .unnumbered}
